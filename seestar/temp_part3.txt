        if chw_like:
            layout_in = "CHW"
            channels = data
        else:
            layout_in = "HWC"
            channels = np.moveaxis(data, -1, 0)
        logger.info(
            "[BATCH SIZE=1] 3D input detected: %d channels (input %s â†’ internal CHW)",
            channels.shape[0],
            layout_in,
        )
        reproj_list = []
        footprint_list = []
        for c in range(channels.shape[0]):
            r, f = reproject_interp(
                (channels[c], input_wcs), target_wcs, shape_out, parallel=False
            )
            reproj_list.append(r)
            footprint_list.append(f)
        reproj = np.stack(reproj_list, axis=0)
        footprint = np.stack(footprint_list, axis=0)
    else:
        raise ValueError(
            f"Unsupported image ndim={data.ndim} in _reproject_worker"
        )

    logger.info(
        "[BATCH SIZE=1] reprojected shape=%s, footprint: min=%.3g, max=%.3g",
        reproj.shape,
        float(np.nanmin(footprint)),
        float(np.nanmax(footprint)),
    )

    footprint = np.nan_to_num(footprint, nan=0.0)
    weight_map = footprint.astype(np.float32, copy=False)

    radial = make_radial_weight_map(shape_out[0], shape_out[1]).astype(
        np.float32, copy=False
    )
    if weight_map.ndim == 3:
        if weight_map.shape[0] in (1, 3, 4) and weight_map.shape[1:] == (
            shape_out[0],
            shape_out[1],
        ):
            weight_map *= radial[None, :, :]
        elif weight_map.shape[2] in (1, 3, 4) and weight_map.shape[0:2] == (
            shape_out[0],
            shape_out[1],
        ):
            weight_map *= radial[..., None]
        else:  # fallback broadcast
            weight_map *= radial
    else:
        weight_map *= radial

    reproj = np.asarray(reproj, dtype=np.float32)
    if reproj.ndim == 3 and reproj.shape[0] in (1, 3, 4) and reproj.shape[1:] == (
        shape_out[0],
        shape_out[1],
    ):
        reproj *= weight_map
    elif reproj.ndim == 3 and reproj.shape[2] in (1, 3, 4) and reproj.shape[0:2] == (
        shape_out[0],
        shape_out[1],
    ):
        reproj *= weight_map
    else:
        reproj *= weight_map

    valid_pixels = int(np.count_nonzero(weight_map))
    logger.debug(
        "[FOOTPRINT_MASK] Applied footprint mask to batch (%d valid pixels)",
        valid_pixels,
    )

    # Optional background matching (sigma-clipped median subtraction)
    if match_background:
        try:
            from seestar.enhancement.reproject_utils import (
                subtract_sigma_clipped_median,
            )
            reproj, med_val = subtract_sigma_clipped_median(reproj)
            logger.debug(
                "[MATCH_BG] Applied sigma-clipped background offset (%.5f) to %s",
                float(med_val),
                os.path.basename(fits_path),
            )
        except Exception as e:
            logger.warning(
                "[MATCH_BG] Background match failed for %s: %s",
                os.path.basename(fits_path),
                e,
            )

    return reproj.astype(np.float32, copy=False), weight_map.astype(np.float32, copy=False)


def _stack_worker(args):
    """Worker for heavy stacking computations."""
    (
        mode,
        images,
        weights,
        kappa_low,
        kappa_high,
        winsor_limits,
        apply_rewinsor,
    ) = args

    from seestar.core.stack_methods import (
        _stack_kappa_sigma,
        _stack_linear_fit_clip,
        _stack_mean,
        _stack_median,
        _stack_winsorized_sigma,
    )

    if mode == "winsorized-sigma":
        res = _stack_winsorized_sigma(
            images,
            weights,
            kappa=max(kappa_low, kappa_high),
            winsor_limits=winsor_limits,
            apply_rewinsor=apply_rewinsor,
        )
        gc.collect()  # FIX MEMLEAK
        return res
    elif mode == "kappa-sigma":
        return _stack_kappa_sigma(
            images,
            weights,
            sigma_low=kappa_low,
            sigma_high=kappa_high,
        )
    elif mode == "linear_fit_clip":
        return _stack_linear_fit_clip(images, weights)
    elif mode == "median":
        return _stack_median(images, weights)
    else:
        return _stack_mean(images, weights)


def drizzle_batch_worker(args):
    """Wrapper used by the drizzle process pool."""
    self = args[0]
    batch_temp_filepaths_list = args[1]
    current_batch_num = args[2] if len(args) > 2 else 0
    total_batches_est = args[3] if len(args) > 3 else 0
    weight_map_override = args[4] if len(args) > 4 else None
    return self._process_incremental_drizzle_batch(
        batch_temp_filepaths_list,
        current_batch_num,
        total_batches_est,
        weight_map_override,
    )


def drizzle_final_worker(args):
    """Wrapper used for the final drizzle combination."""
    self = args[0]
    files_list = args[1]
    wcs = args[2]
    shape = args[3]
    return self._combine_intermediate_drizzle_batches(files_list, wcs, shape)


def _quality_metrics_worker(image_data):
    """Compute SNR and star count in a separate process."""
    import numpy as np
    import astroalign as aa

    scores = {"snr": 0.0, "stars": 0.0}
    star_msg = None
    num_stars = 0

    if image_data is None:
        return scores, star_msg, num_stars

    # --- Calculate SNR ---
    try:
        if image_data.ndim == 3 and image_data.shape[2] == 3:
            data_for_snr = (
                0.299 * image_data[..., 0]
                + 0.587 * image_data[..., 1]
                + 0.114 * image_data[..., 2]
            )
        elif image_data.ndim == 2:
            data_for_snr = image_data
        else:
            raise ValueError("Unsupported image format for SNR")

        finite_data = data_for_snr[np.isfinite(data_for_snr)]
        if finite_data.size < 50:
            raise ValueError("Not enough finite pixels for SNR")

        signal = np.median(finite_data)
        mad = np.median(np.abs(finite_data - signal))
        noise_std = max(mad * 1.4826, 1e-9)
        snr = signal / noise_std
        scores["snr"] = float(np.clip(snr, 0.0, 1000.0))
