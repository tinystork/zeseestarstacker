                                self._move_to_unaligned(file_path)

                    queue_ref.task_done()
                    _log_mem(f"after_image_{iteration_count}")
                    getattr(self, "_indices_cache", {}).clear()
                    gc.collect()
                except Empty:
                    # --- NOUVELLE LOGIQUE POUR G√âRER LES DOSSIERS ADDITIONNELS (D√âBUT) ---
                    logger.debug(
                        f"DEBUG QM [_worker / EmptyExcept]: Queue vide. V√©rification des dossiers additionnels."
                    )
                    new_files_added_from_additional_folder = 0
                    folder_to_process_from_additional = None

                    # Prot√©ger l'acc√®s √† self.additional_folders avec le Lock
                    with self.folders_lock:
                        if (
                            self.additional_folders
                        ):  # Si des dossiers additionnels sont en attente
                            folder_to_process_from_additional = (
                                self.additional_folders.pop(0)
                            )  # Prendre le premier et le retirer
                            logger.debug(
                                f"DEBUG QM [_worker / EmptyExcept]: Dossier additionnel trouv√© et retir√©: '{os.path.basename(folder_to_process_from_additional)}'."
                            )
                            # Mettre √† jour le statut dans l'UI imm√©diatement (m√™me si pas de fichiers √† l'int√©rieur)
                            self.update_progress(
                                f"üîç Scan du dossier additionnel: {os.path.basename(folder_to_process_from_additional)}...",
                                None,
                            )
                        else:
                            logger.debug(
                                f"DEBUG QM [_worker / EmptyExcept]: self.additional_folders est vide (pas de dossiers additionnels en attente)."
                            )

                    if folder_to_process_from_additional:
                        # Mettre √† jour self.current_folder pour que les logs d'erreurs √©ventuelles soient pertinents
                        self.current_folder = folder_to_process_from_additional
                        new_files_added_from_additional_folder = (
                            self._add_files_to_queue(folder_to_process_from_additional)
                        )
                        logger.debug(
                            f"DEBUG QM [_worker / EmptyExcept]: {new_files_added_from_additional_folder} nouveaux fichiers ajout√©s de '{os.path.basename(folder_to_process_from_additional)}'."
                        )

                        # Notifier le GUI que le nombre de dossiers additionnels a diminu√©
                        # (La mise √† jour de l'affichage du nombre de dossiers dans l'UI via le callback)
                        self.update_progress(
                            f"folder_count_update:{len(self.additional_folders)}"
                        )

                        if new_files_added_from_additional_folder > 0:
                            # Si de nouveaux fichiers ont √©t√© ajout√©s, on continue la boucle
                            # et la queue sera trait√©e √† la prochaine it√©ration.
                            logger.debug(
                                f"DEBUG QM [_worker / EmptyExcept]: Nouveaux fichiers d√©tect√©s, continuer la boucle."
                            )
                            continue  # <-- CRUCIAL: Retourne au d√©but de la boucle while pour traiter les nouveaux fichiers
                        else:
                            # Si le dossier additionnel √©tait vide de FITS, on log l'info.
                            self.update_progress(
                                f"   ‚ÑπÔ∏è Dossier '{os.path.basename(folder_to_process_from_additional)}' ne contient aucun fichier FITS √† traiter. Passons au suivant ou finalisons."
                            )
                            logger.debug(
                                f"DEBUG QM [_worker / EmptyExcept]: Dossier additionnel vide, pas de nouveaux fichiers √† traiter."
                            )
                            # Si le dossier additionnel ne contenait pas de fichiers FITS, la queue reste vide.
                            # On laisse la logique de fin de traitement prendre le relais √† la prochaine it√©ration.
                            # Pas de 'continue' ici, pour permettre l'√©valuation de la condition finale de sortie.
                            pass

                    # Si aucun dossier additionnel n'a √©t√© trouv√© OU si le dossier trouv√© √©tait vide de FITS
                    # (et qu'on est arriv√© ici sans 'continue' pr√©c√©dent)
                    if not self.additional_folders and self.queue.empty():
                        self.update_progress(
                            "INFO: Plus aucun fichier ni dossier suppl√©mentaire. Fin de la boucle de traitement.",
                            None,
                        )
                        logger.debug(
                            f"DEBUG QM [_worker / EmptyExcept]: Condition de sortie (self.additional_folders et queue vides) remplie. BREAK."
                        )
                        break  # <-- CRUCIAL: Sortie normale de la boucle while
                    else:
                        # Si self.additional_folders n'est PAS vide (m√™me apr√®s le pop d'un √©l√©ment, d'autres ont pu √™tre ajout√©s √† la vol√©e),
                        # ou si la queue n'est pas vide (si _add_files_to_queue a r√©ussi),
                        # alors on devrait continuer. Si on est ici, la queue est vide.
                        # Cela signifie que self.additional_folders doit avoir des √©l√©ments pour que la boucle continue.
                        # Sinon, c'est une boucle infinie si on arrive ici sans `break` ou `continue` et que la queue est vide.
                        # Un `time.sleep` est alors n√©cessaire pour √©viter le CPU √† 100%.
                        self.update_progress(
                            "INFO: File d'attente vide, en attente de nouveaux ...",
                            None,
                        )
                        logger.debug(
                            f"DEBUG QM [_worker / EmptyExcept]: Queue vide. self.additional_folders n'est PAS vide (il reste des dossiers √† traiter), OU un 'continue' a √©t√© manqu√©. Sleep et rev√©rification..."
                        )
                        time.sleep(
                            0.5
                        )  # Attendre un peu avant de refaire un `get` (pour √©viter boucle serr√©e)
                        continue  # <-- CRUCIAL: Retourne au d√©but de la boucle `while` pour re-tenter de prendre un item ou un autre dossier additionnel
                    # --- NOUVELLE LOGIQUE POUR G√âRER LES DOSSIERS ADDITIONNELS (FIN) ---

            # ==============================================================
            # === SECTION 3 : TRAITEMENT FINAL APR√àS LA BOUCLE PRINCIPALE ===
            # ==============================================================
            logger.debug(
                f"DEBUG QM [_worker V_DrizIncrTrue_Fix1 / FIN DE BOUCLE WHILE]:"
            )  # Version Log
            logger.debug(f"  >> self.stop_processing est: {self.stop_processing}")
            logger.debug(
                f"  >> Taille de all_aligned_files_with_info_for_mosaic IMM√âDIATEMENT APR√àS LA BOUCLE WHILE: {len(all_aligned_files_with_info_for_mosaic)}"
            )
            if all_aligned_files_with_info_for_mosaic:
                logger.debug(
                    f"  >> Premier item (pour v√©rif type): {type(all_aligned_files_with_info_for_mosaic[0])}, len: {len(all_aligned_files_with_info_for_mosaic[0]) if isinstance(all_aligned_files_with_info_for_mosaic[0], tuple) else 'N/A'}"
                )

            logger.debug(
                f"DEBUG QM [_worker V_DrizIncrTrue_Fix1]: Sortie de la boucle principale. D√©but de la phase de finalisation..."
            )
            logger.debug(f"  √âTAT FINAL AVANT BLOC if/elif/else de finalisation:")
            logger.debug(f"    - self.stop_processing: {self.stop_processing}")
            logger.debug(f"    - self.is_mosaic_run: {self.is_mosaic_run}")
            if self.is_mosaic_run:
                logger.debug(
                    f"      - Mode align.: '{self.mosaic_alignment_mode}', Nb items mosa√Øque: {len(all_aligned_files_with_info_for_mosaic)}"
                )
            logger.debug(
                f"    - self.drizzle_active_session (std): {self.drizzle_active_session}"
            )
            if self.drizzle_active_session and not self.is_mosaic_run:
                logger.debug(
                    f"      - Mode Drizzle (std): '{self.drizzle_mode}', Nb lots Drizzle interm.: {len(self.intermediate_drizzle_batch_files)}"
                )
            logger.debug(
                f"    - self.images_in_cumulative_stack (classique/DrizIncrVRAI): {self.images_in_cumulative_stack}"
            )
            logger.debug(
                f"    - current_batch_items_with_masks_for_stack_batch (non trait√© si dernier lot partiel): {len(current_batch_items_with_masks_for_stack_batch)}"
            )
