            )
        elif is_drizzle_final_mode_with_data:
            current_operation_mode_log_desc = (
                f"Drizzle Standard Final (donn√©es lot fournies)"
            )
            current_operation_mode_log_fits = "Drizzle Standard Final (from batch data)"
        elif is_classic_reproject_mode:
            current_operation_mode_log_desc = "Stacking Classique Reproject"
            current_operation_mode_log_fits = "Classic Stacking Reproject"
        elif is_classic_stacking_mode:
            current_operation_mode_log_desc = "Stacking Classique SUM/W (memmaps)"
            current_operation_mode_log_fits = "Classic Stacking SUM/W (memmaps)"
        else:
            if not self.drizzle_active_session and not self.is_mosaic_run:
                current_operation_mode_log_desc = (
                    "Stacking Classique SUM/W (memmaps) - Fallback"
                )
                current_operation_mode_log_fits = (
                    "Classic Stacking SUM/W (memmaps) - Fallback"
                )
                is_classic_stacking_mode = True

        self.update_progress(
            f"  DEBUG QM: Mode d'op√©ration d√©tect√© pour sauvegarde: {current_operation_mode_log_desc}"
        )
        logger.debug(
            f"  DEBUG QM: Mode d'op√©ration d√©tect√© pour sauvegarde: {current_operation_mode_log_desc}"
        )
        logger.debug("=" * 80 + "\n")
        self.update_progress(
            f"üíæ Pr√©paration sauvegarde finale (Mode: {current_operation_mode_log_desc})..."
        )

        final_image_initial_raw = None  # Donn√©es "brutes" apr√®s combinaison (ADU ou [0,1] si classique d√©j√† normalis√©)
        final_wht_map_for_postproc = (
            None  # Carte de poids 2D pour certains post-traitements
        )
        background_model_photutils = None  # Mod√®le de fond si Photutils BN est appliqu√©

        self.raw_adu_data_for_ui_histogram = (
            None  # Sera les donn√©es ADU-like pour l'histogramme de l'UI
        )
        # self.last_saved_data_for_preview est celui qui sera envoy√© √† l'UI pour son affichage
        # Il doit √™tre normalis√© [0,1] MAIS NON STRETCH√â COSM√âTIQUEMENT par le backend.

        try:
            # --- √âTAPE 1: Obtenir final_image_initial_raw et final_wht_map_for_postproc ---
            # (La logique pour obtenir ces donn√©es reste la m√™me que votre version pr√©c√©dente)
            # ... (Bloc if/elif/else pour les modes reproject, drizzle, classique) ...
            # (Je reprends la logique de votre dernier log `taraceback.txt` pour cette partie)
            if is_reproject_mosaic_mode:
                self.update_progress(
                    "  DEBUG QM [SaveFinalStack] Mode: Mosa√Øque Reproject"
                )
                logger.debug("  DEBUG QM [SaveFinalStack] Mode: Mosa√Øque Reproject")
                final_image_initial_raw = drizzle_final_sci_data.astype(np.float32)
                if drizzle_final_wht_data.ndim == 3:
                    final_wht_map_for_postproc = np.mean(
                        drizzle_final_wht_data, axis=2
                    ).astype(np.float32)
                else:
                    final_wht_map_for_postproc = drizzle_final_wht_data.astype(
                        np.float32
                    )
                final_wht_map_for_postproc = np.maximum(final_wht_map_for_postproc, 0.0)
                self._close_memmaps()
                self.update_progress(
                    f"    DEBUG QM: Mosaic Reproject - final_image_initial_raw - Range: [{np.nanmin(final_image_initial_raw):.4g} - {np.nanmax(final_image_initial_raw):.4g}]"
                )
                logger.debug(
                    f"    DEBUG QM: Mosaic Reproject - final_image_initial_raw - Range: [{np.nanmin(final_image_initial_raw):.4g} - {np.nanmax(final_image_initial_raw):.4g}]"
                )

            elif is_true_incremental_drizzle_from_objects:
                self.update_progress(
                    "  DEBUG QM [SaveFinalStack] Mode: Drizzle Incr√©mental VRAI"
                )
                logger.debug(
                    "  DEBUG QM [SaveFinalStack] Mode: Drizzle Incr√©mental VRAI"
                )
                if (
                    not self.incremental_drizzle_objects
                    or len(self.incremental_drizzle_objects) != 3
                ):
                    raise ValueError(
                        "Objets Drizzle incremental invalides ou manquants."
                    )
                sci_arrays_hw_list = [
                    d.out_img for d in self.incremental_drizzle_objects
                ]
                wht_arrays_hw_list = [
                    d.out_wht for d in self.incremental_drizzle_objects
                ]

                if not any(
                    np.any(np.asarray(w, dtype=float) != 0) for w in wht_arrays_hw_list
                ):
                    self.update_progress(
                        "‚ùå Drizzle Incremental: all weight maps are zero. Aborting final stack.",
                        "ERROR",
                    )
                    logger.error(
                        "ERROR QM [_save_final_stack]: All drizzle weights are zero."
                    )
                    self.final_stacked_path = None
                    return

                avg_img_channels_list = []
                processed_wht_channels_list_for_mean = []
                for c in range(3):
                    sci_ch = sci_arrays_hw_list[c].astype(np.float32)
                    wht_ch = np.maximum(wht_arrays_hw_list[c].astype(np.float32), 0.0)
                    processed_wht_channels_list_for_mean.append(wht_ch)
                    avg_img_channels_list.append(
                        drizzle_finalize(
                            sci_ch,
                            wht_ch,
                            use_gpu=getattr(self, "use_gpu", False),
                        )
                    )
                final_image_initial_raw = np.stack(avg_img_channels_list, axis=-1)
                final_wht_map_for_postproc = np.mean(
                    np.stack(processed_wht_channels_list_for_mean, axis=-1), axis=2
                ).astype(np.float32)
                final_wht_map_for_postproc = np.maximum(final_wht_map_for_postproc, 0.0)
                self.update_progress(
                    f"    DEBUG QM: Drizzle Incr VRAI - final_image_initial_raw - Range: [{np.nanmin(final_image_initial_raw):.4g} - {np.nanmax(final_image_initial_raw):.4g}]"
                )
                logger.debug(
                    f"    DEBUG QM: Drizzle Incr VRAI - final_image_initial_raw - Range: [{np.nanmin(final_image_initial_raw):.4g} - {np.nanmax(final_image_initial_raw):.4g}]"
                )

            elif is_drizzle_final_mode_with_data:
                self.update_progress(
                    "  DEBUG QM [SaveFinalStack] Mode: Drizzle Standard Final (depuis donn√©es de lot)"
                )
                logger.debug(
                    "  DEBUG QM [SaveFinalStack] Mode: Drizzle Standard Final (depuis donn√©es de lot)"
                )
                if drizzle_final_sci_data is None or drizzle_final_wht_data is None:
                    raise ValueError(
                        "Donnees de lot Drizzle final (sci/wht) manquantes."
                    )
                sci_arr = drizzle_final_sci_data
                if sci_arr.ndim == 4 and sci_arr.shape[0] == 1:
                    sci_arr = sci_arr[0]
                if sci_arr.ndim == 3 and sci_arr.shape[0] == 3:
                    sci_arr = np.moveaxis(sci_arr, 0, -1)
                sci_data_float64 = sci_arr.astype(np.float64)

                wht_arr = drizzle_final_wht_data
                if wht_arr.ndim == 4 and wht_arr.shape[0] == 1:
                    wht_arr = wht_arr[0]
                wht_data_float64 = wht_arr.astype(np.float64)
                wht_data_clipped_positive = np.maximum(wht_data_float64, 0.0)

                if wht_arr.ndim == 3:
                    wht3d = (
                        wht_data_clipped_positive
                        if wht_arr.shape[-1] == 3
                        else np.moveaxis(wht_data_clipped_positive, 0, -1)
                    )
                    final_wht_map_for_postproc = np.mean(wht3d, axis=2).astype(
                        np.float32
                    )
                    wht_for_div = wht3d
                else:
                    final_wht_map_for_postproc = wht_data_clipped_positive.astype(
                        np.float32
                    )
                    wht_for_div = wht_data_clipped_positive[:, :, np.newaxis]

                final_image_initial_raw = drizzle_finalize(
                    sci_data_float64,
                    wht_for_div,
                    use_gpu=getattr(self, "use_gpu", False),
                )
                self._close_memmaps()
                self.update_progress(
                    f"    DEBUG QM: Drizzle Std Final - final_image_initial_raw - Range: [{np.nanmin(final_image_initial_raw):.4g} - {np.nanmax(final_image_initial_raw):.4g}]"
                )
                logger.debug(
                    f"    DEBUG QM: Drizzle Std Final - final_image_initial_raw - Range: [{np.nanmin(final_image_initial_raw):.4g} - {np.nanmax(final_image_initial_raw):.4g}]"
                )

            elif is_classic_reproject_mode:
                self.update_progress(
                    "  DEBUG QM [SaveFinalStack] Mode: Stacking Classique Reproject"
                )
                logger.debug(
                    "  DEBUG QM [SaveFinalStack] Mode: Stacking Classique Reproject"
                )
                final_image_initial_raw = drizzle_final_sci_data.astype(np.float32)
                if drizzle_final_wht_data.ndim == 3:
                    final_wht_map_for_postproc = np.mean(
                        drizzle_final_wht_data, axis=2
                    ).astype(np.float32)
                else:
                    final_wht_map_for_postproc = drizzle_final_wht_data.astype(
                        np.float32
                    )
                final_wht_map_for_postproc = np.maximum(final_wht_map_for_postproc, 0.0)
                self._close_memmaps()
                self.update_progress(
                    f"    DEBUG QM: Classic Reproject - final_image_initial_raw - Range: [{np.nanmin(final_image_initial_raw):.4g} - {np.nanmax(final_image_initial_raw):.4g}]"
                )
                logger.debug(
                    f"    DEBUG QM: Classic Reproject - final_image_initial_raw - Range: [{np.nanmin(final_image_initial_raw):.4g} - {np.nanmax(final_image_initial_raw):.4g}]"
                )

            else:  # SUM/W Classique
