            auto_rotate=True,
        )
        if out_wcs is None or out_shape is None:
            self.update_progress("⚠️ Échec du calcul de la grille finale.", "WARN")
            return

        self.reference_wcs_object = out_wcs
        self._close_memmaps()
        self._create_sum_wht_memmaps(out_shape)

        for path, wcs_obj, hdr in cache_list:
            try:
                with fits.open(path, memmap=False) as hdul:
                    dat = hdul[0].data.astype(np.float32)
                if dat.ndim == 3 and dat.shape[0] in (3, 4):
                    dat = np.moveaxis(dat, 0, -1)
                cov = np.ones(dat.shape[:2], dtype=np.float32)
                reproj_img, cov = self._reproject_to_reference(dat, wcs_obj)
                self._combine_batch_result(reproj_img, hdr, cov, batch_wcs=None)
                if hasattr(self.cumulative_sum_memmap, "flush"):
                    self.cumulative_sum_memmap.flush()
                if hasattr(self.cumulative_wht_memmap, "flush"):
                    self.cumulative_wht_memmap.flush()
            except Exception as e:
                self.update_progress(
                    f"⚠️ Reprojection finale ignorée pour {os.path.basename(path)}: {e}",
                    "WARN",
                )

        self._save_final_stack(output_filename_suffix="_classic_sumw")

    def _save_and_solve_classic_batch(self, stacked_np, wht_2d, header, batch_idx):
        """Save a classic batch and optionally solve/reproject it."""
        out_dir = os.path.join(self.output_folder, "classic_batch_outputs")
        os.makedirs(out_dir, exist_ok=True)

        sci_fits = os.path.join(out_dir, f"classic_batch_{batch_idx:03d}.fits")
        wht_paths: list[str] = []

        final_stacked = stacked_np
        final_wht = wht_2d
        np.nan_to_num(final_wht, copy=False)
        # Potential WCS present on the incoming header (e.g. from drizzle)
        input_wcs = None
        try:
            input_wcs = WCS(header, naxis=2)
        except Exception:
            pass

        # Crop the stacked tile before solving so the WCS corresponds
        # to the final data saved on disk.
        if (
            getattr(self, "apply_master_tile_crop", False)
            and getattr(self, "master_tile_crop_percent_decimal", 0.0) > 0
        ):
            try:
                cp = self.master_tile_crop_percent_decimal
                dh = int(final_stacked.shape[0] * cp)
                dw = int(final_stacked.shape[1] * cp)
                if dh > 0 or dw > 0:
                    end_h = -dh if dh != 0 else None
                    end_w = -dw if dw != 0 else None
                    final_stacked = final_stacked[dh:end_h, dw:end_w, :]
                    final_wht = final_wht[dh:end_h, dw:end_w]
                    header["CRPIX1"] = header.get("CRPIX1", 0) - dw
                    header["CRPIX2"] = header.get("CRPIX2", 0) - dh
                    header["NAXIS1"] = final_stacked.shape[1]
                    header["NAXIS2"] = final_stacked.shape[0]
            except Exception:
                pass

        # Update WCS object after potential cropping adjustments
        try:
            input_wcs = WCS(header, naxis=2)
        except Exception:
            input_wcs = None

        # Propagate basic pointing information so intermediate batches remain
        # self-contained even when solving is deferred. RA/DEC are taken from
        # the WCS if available or fall back to the reference header.
        if "RA" not in header:
            if "CRVAL1" in header:
                header["RA"] = (
                    float(header["CRVAL1"]),
                    "[deg] Approx pointing RA from WCS",
                )
            elif (
                getattr(self, "reference_header_for_wcs", None) is not None
                and "RA" in self.reference_header_for_wcs
            ):
                header["RA"] = (
                    float(self.reference_header_for_wcs["RA"]),
                    (
                        self.reference_header_for_wcs.comments["RA"]
                        if "RA" in self.reference_header_for_wcs.comments
                        else "[deg] Pointing RA from reference header"
                    ),
                )
        if "DEC" not in header:
            if "CRVAL2" in header:
                header["DEC"] = (
                    float(header["CRVAL2"]),
                    "[deg] Approx pointing DEC from WCS",
                )
            elif (
                getattr(self, "reference_header_for_wcs", None) is not None
                and "DEC" in self.reference_header_for_wcs
            ):
                header["DEC"] = (
                    float(self.reference_header_for_wcs["DEC"]),
                    (
                        self.reference_header_for_wcs.comments["DEC"]
                        if "DEC" in self.reference_header_for_wcs.comments
                        else "[deg] Pointing DEC from reference header"
                    ),
                )

        # Save the batch to disk before solving so the WCS can be written
        # directly to the final FITS file.
        data_cxhxw = np.moveaxis(final_stacked, -1, 0)
        header["NAXIS"] = 3
        header["NAXIS1"] = data_cxhxw.shape[2]
        header["NAXIS2"] = data_cxhxw.shape[1]
        header["NAXIS3"] = data_cxhxw.shape[0]
        header["CTYPE3"] = "RGB"
        header["EXTNAME"] = "RGB"
        header["BITPIX"] = -32
        header["SIMPLE"] = True
        try:
            header["CHNAME1"] = "R"
            header["CHNAME2"] = "G"
            header["CHNAME3"] = "B"
        except Exception:
            pass

        fits.PrimaryHDU(data=data_cxhxw, header=header).writeto(
            sci_fits, overwrite=True, output_verify="ignore"
        )

        for ch_i in range(final_stacked.shape[2]):
            wht_path = os.path.join(
                out_dir, f"classic_batch_{batch_idx:03d}_wht_{ch_i}.fits"
            )
            fits.PrimaryHDU(data=final_wht.astype(np.float32)).writeto(
                wht_path, overwrite=True, output_verify="ignore"
            )
            wht_paths.append(wht_path)

        # In reproject+coadd mode we postpone solving until all batches are
        # stacked. Only run the solver here when explicitly requested via
        # ``solve_batches``.
        run_astap = self.solve_batches and not self.reproject_coadd_final
        solved_ok = True

        if run_astap:
            solved_ok = self._run_astap_and_update_header(sci_fits)
            if solved_ok:
                header = fits.getheader(sci_fits)
            else:
                if (
                    self.reference_header_for_wcs is not None
                    and not self.reproject_coadd_final
                ):
                    if (
                        input_wcs is not None
                        and self.reference_wcs_object is not None
                        and self.reference_shape is not None
                    ):
                        try:
                            final_stacked = reproject_to_reference_wcs(
                                final_stacked,
                                input_wcs,
                                self.reference_wcs_object,
                                self.reference_shape,
                            )
                            final_wht = reproject_to_reference_wcs(
                                final_wht,
                                input_wcs,
                                self.reference_wcs_object,
                                self.reference_shape,
                            )
                        except Exception:
                            pass
