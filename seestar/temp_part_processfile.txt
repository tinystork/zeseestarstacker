                    (batch_image[:, :, ch], batch_wcs),
                    self.reference_wcs_object,
                    shape_out=target_shape,
                )
                channels.append(reproj_ch)
            batch_image = np.stack(channels, axis=2)
        else:
            batch_image, _ = reproject_interp(
                (batch_image, batch_wcs),
                self.reference_wcs_object,
                shape_out=target_shape,
            )

        batch_wht, _ = reproject_interp(
            (batch_wht, batch_wcs),
            self.reference_wcs_object,
            shape_out=target_shape,
        )

        return batch_image.astype(np.float32), batch_wht.astype(np.float32)

    ############################################################################################################################

    # --- DANS LA CLASSE SeestarQueuedStacker DANS seestar/queuep/queue_manager.py ---

    def _process_file(
        self,
        file_path,
        reference_image_data_for_alignment,  # Image de l'ANCRE pour FastAligner ou réf. pour Astroalign std
        solve_astrometry_for_this_file=False,
        fa_orb_features_config=5000,
        fa_min_abs_matches_config=10,
        fa_min_ransac_inliers_value_config=4,
        fa_ransac_thresh_config=3.0,
        daofind_fwhm_config=3.5,
        daofind_threshold_sigma_config=6.0,
        max_stars_to_describe_config=750,
        align_on_disk=None,
    ):
        """
        Traite un seul fichier image.
        Version: V_ProcessFile_M81_Debug_UltimateLog_1
        """
        if threading.current_thread() is threading.main_thread():
            logger.warning(
                "_process_file executing on main thread - this may freeze the GUI"
            )
        if align_on_disk is None:
            align_on_disk = getattr(self, "align_on_disk", False)
        file_name = os.path.basename(file_path)
        quality_scores = {"snr": 0.0, "stars": 0.0}
        logger.debug(
            f"\nDEBUG QM [_process_file V_ProcessFile_M81_Debug_UltimateLog_1]:"
        )  # Modifié le nom de version pour le log
        logger.debug(f"  >> Fichier: '{file_name}'")
        logger.debug(
            f"  >> Solve Astrometry Directly: {solve_astrometry_for_this_file}"
        )
        logger.debug(
            f"  >> is_mosaic_run: {self.is_mosaic_run}, mosaic_alignment_mode: {getattr(self, 'mosaic_alignment_mode', 'N/A')}"
        )
        logger.debug(f"  >> drizzle_active_session: {self.drizzle_active_session}")

        header_final_pour_retour = None
        img_data_array_loaded = None
        prepared_img_after_initial_proc = None
        image_for_alignment_or_drizzle_input = None
        wcs_final_pour_retour = None
        data_final_pour_retour = None
        valid_pixel_mask_2d = None
        matrice_M_calculee = None
        align_method_log_msg = "Unknown"
        tmp_align_in_path = None

        try:
            logger.debug(f"  -> [1/7] Chargement/Validation FITS pour '{file_name}'...")
            loaded_data_tuple = load_and_validate_fits(file_path)
            if loaded_data_tuple and loaded_data_tuple[0] is not None:
                img_data_array_loaded, header_from_load = loaded_data_tuple
                header_final_pour_retour = (
                    header_from_load.copy() if header_from_load else fits.Header()
                )
            else:
                header_temp_fallback = None
                if loaded_data_tuple and loaded_data_tuple[1] is not None:
                    header_temp_fallback = loaded_data_tuple[1].copy()
                else:
                    try:
                        header_temp_fallback = fits.getheader(file_path)
                    except:
                        header_temp_fallback = fits.Header()
                header_final_pour_retour = header_temp_fallback
                raise ValueError(
                    "Échec chargement/validation FITS (données non retournées)."
                )
            header_final_pour_retour["_SRCFILE"] = (
                file_name,
                "Original source filename",
            )
            logger.debug(
                f"     - FITS original (après load_and_validate): Range: [{np.min(img_data_array_loaded):.4g}, {np.max(img_data_array_loaded):.4g}], Shape: {img_data_array_loaded.shape}, Dtype: {img_data_array_loaded.dtype}"
            )

            logger.debug(f"  -> [2/7] Vérification variance pour '{file_name}'...")
            std_dev = np.std(img_data_array_loaded)
            variance_threshold = 1e-4  # anciennement 0.0015
            if std_dev < variance_threshold:
                raise ValueError(
                    f"Faible variance: {std_dev:.4f} (seuil: {variance_threshold})."
                )
            logger.debug(f"     - Variance OK (std: {std_dev:.4f}).")

            logger.debug(f"  -> [3/7] Pré-traitement pour '{file_name}'...")
            prepared_img_after_initial_proc = img_data_array_loaded.astype(np.float32)
            logger.debug(
                f"     - (a) Après conversion float32: Range: [{np.min(prepared_img_after_initial_proc):.4g}, {np.max(prepared_img_after_initial_proc):.4g}]"
            )

            is_color_after_preprocessing = False
            if prepared_img_after_initial_proc.ndim == 2:
                bayer_pattern_from_header = header_final_pour_retour.get(
                    "BAYERPAT", self.bayer_pattern
                )
                pattern_upper = (
                    bayer_pattern_from_header.upper()
                    if isinstance(bayer_pattern_from_header, str)
                    else self.bayer_pattern.upper()
                )
                if pattern_upper in ["GRBG", "RGGB", "GBRG", "BGGR"]:
                    prepared_img_after_initial_proc = debayer_image(
                        prepared_img_after_initial_proc, pattern_upper
                    )
                    is_color_after_preprocessing = True
                    logger.debug(
                        f"     - (b) Image débayerisée. Range: [{np.min(prepared_img_after_initial_proc):.4g}, {np.max(prepared_img_after_initial_proc):.4g}]"
                    )
            elif (
                prepared_img_after_initial_proc.ndim == 3
                and prepared_img_after_initial_proc.shape[2] == 3
            ):
                is_color_after_preprocessing = True
            else:
                raise ValueError(
                    f"Shape image {prepared_img_after_initial_proc.shape} non supportée post-chargement."
                )

            if is_color_after_preprocessing:
                try:
                    r_ch, g_ch, b_ch = (
                        prepared_img_after_initial_proc[..., 0],
                        prepared_img_after_initial_proc[..., 1],
                        prepared_img_after_initial_proc[..., 2],
                    )
                    med_r, med_g, med_b = (
                        np.median(r_ch),
                        np.median(g_ch),
                        np.median(b_ch),
                    )
                    if med_g > 1e-6:
                        gain_r = np.clip(med_g / max(med_r, 1e-6), 0.5, 2.0)
                        gain_b = np.clip(med_g / max(med_b, 1e-6), 0.5, 2.0)
                        prepared_img_after_initial_proc[..., 0] *= gain_r
                        prepared_img_after_initial_proc[..., 2] *= gain_b
                    logger.debug(
                        f"     - (c) WB basique appliquée. Range: [{np.min(prepared_img_after_initial_proc):.4g}, {np.max(prepared_img_after_initial_proc):.4g}]"
                    )
                except Exception as e_wb:
                    logger.debug(f"WARN QM [_process_file]: Erreur WB basique: {e_wb}")

            if self.correct_hot_pixels:
                prepared_img_after_initial_proc = detect_and_correct_hot_pixels(
                    prepared_img_after_initial_proc,
                    self.hot_pixel_threshold,
                    self.neighborhood_size,
                )
                logger.debug(
                    f"     - (d) Correction HP. Range: [{np.min(prepared_img_after_initial_proc):.4g}, {np.max(prepared_img_after_initial_proc):.4g}]"
                )

            is_drizzle_or_mosaic_mode = (
                self.drizzle_active_session or self.is_mosaic_run
            )
            logger.debug(
                f"     - (e) is_drizzle_or_mosaic_mode: {is_drizzle_or_mosaic_mode}"
            )

            if align_on_disk:
                tmp_align_in_path = tempfile.mktemp(suffix=".npy")
                mm_in = np.lib.format.open_memmap(
                    tmp_align_in_path,
                    mode="w+",
                    dtype=np.float32,
                    shape=prepared_img_after_initial_proc.shape,
                )
                mm_in[:] = prepared_img_after_initial_proc
                mm_in.flush()
                image_for_alignment_or_drizzle_input = mm_in
            else:
                image_for_alignment_or_drizzle_input = (
                    prepared_img_after_initial_proc.copy()
                )
            logger.debug(
                f"     - (f) image_for_alignment_or_drizzle_input (copie de (d)) - Range: [{np.min(image_for_alignment_or_drizzle_input):.4g}, {np.max(image_for_alignment_or_drizzle_input):.4g}]"
            )

            current_max_val = np.nanmax(image_for_alignment_or_drizzle_input)
            if is_drizzle_or_mosaic_mode:
                if current_max_val <= 1.0 + 1e-5 and current_max_val > -1e-5:
                    logger.debug(
                        f"       - (g) DRIZZLE/MOSAIQUE: Détection plage [0,1] (max_val={current_max_val:.4g}). Rescale vers ADU 0-65535."
                    )
                    image_for_alignment_or_drizzle_input = (
                        image_for_alignment_or_drizzle_input * 65535.0
                    )
                    logger.debug(
                        f"         Nouveau range image_for_alignment_or_drizzle_input: [{np.min(image_for_alignment_or_drizzle_input):.4g}, {np.max(image_for_alignment_or_drizzle_input):.4g}]"
                    )
                image_for_alignment_or_drizzle_input = np.clip(
                    image_for_alignment_or_drizzle_input, 0.0, None
                )
                logger.debug(
                    f"     - (h) Pré-traitement final POUR DRIZZLE/MOSAIQUE: image_for_alignment_or_drizzle_input - Range: [{np.min(image_for_alignment_or_drizzle_input):.4g}, {np.max(image_for_alignment_or_drizzle_input):.4g}]"
                )
                data_final_pour_retour = image_for_alignment_or_drizzle_input.astype(
                    np.float32
                )
            else:
                logger.debug(
                    f"     - (g) STACKING CLASSIQUE: image_for_alignment_or_drizzle_input (pour alignement) - Range: [{np.min(image_for_alignment_or_drizzle_input):.4g}, {np.max(image_for_alignment_or_drizzle_input):.4g}]"
                )

            logger.debug(f"  -> [4/7] Alignement/Résolution WCS pour '{file_name}'...")
            logger.debug(
                f"     - AVANT ALIGNEMENT: image_for_alignment_or_drizzle_input - Range: [{np.min(image_for_alignment_or_drizzle_input):.4g}, {np.max(image_for_alignment_or_drizzle_input):.4g}], Shape: {image_for_alignment_or_drizzle_input.shape}"
            )

            if (
                not solve_astrometry_for_this_file
                and self.is_mosaic_run
                and self.mosaic_alignment_mode
                in ["local_fast_fallback", "local_fast_only"]
            ):
                align_method_log_msg = "FastAligner_Attempted"
                fa_success = False
                if (
                    self.local_aligner_instance
                    and reference_image_data_for_alignment is not None
                ):
                    _, M_par_fa, fa_success = self.local_aligner_instance._align_image(
                        image_for_alignment_or_drizzle_input,
                        reference_image_data_for_alignment,
                        file_name,
                        fa_min_abs_matches_config,
                        fa_min_ransac_inliers_value_config,
                        fa_ransac_thresh_config,
                        0.15,
                        daofind_fwhm_config,
                        daofind_threshold_sigma_config,
                        max_stars_to_describe_config,
                    )
                    if fa_success and M_par_fa is not None:
                        align_method_log_msg = "FastAligner_Success"
                        matrice_M_calculee = M_par_fa
                        wcs_final_pour_retour = self.reference_wcs_object
                    else:
                        fa_success = False
                        align_method_log_msg = "FastAligner_Fail"
                else:
                    align_method_log_msg = "LocalAlign_Not_Attempted"
                if not fa_success and self.use_wcs_fallback_for_mosaic:
                    align_method_log_msg += "_Fallback_Attempted"
                    if self.astrometry_solver:
                        solver_settings_for_panel_fallback = {
                            "local_solver_preference": self.local_solver_preference,
                            "api_key": self.api_key,
                            "astap_path": self.astap_path,
                            "astap_data_dir": self.astap_data_dir,
                            "astap_search_radius": self.astap_search_radius,
                            "astap_downsample": self.astap_downsample,
                            "astap_sensitivity": self.astap_sensitivity,
                            "local_ansvr_path": self.local_ansvr_path,
                            "scale_est_arcsec_per_pix": self.reference_pixel_scale_arcsec,
                            "scale_tolerance_percent": 20,
                            "ansvr_timeout_sec": getattr(
                                self, "ansvr_timeout_sec", 120
                            ),
                            "astap_timeout_sec": getattr(
                                self, "astap_timeout_sec", 120
                            ),
                            "astrometry_net_timeout_sec": getattr(
                                self, "astrometry_net_timeout_sec", 300
                            ),
                        }
                        wcs_panel_solved_by_solver = None
                        try:
                            wcs_panel_solved_by_solver = self.astrometry_solver.solve(
                                file_path,
                                header_final_pour_retour,
                                solver_settings_for_panel_fallback,
                                True,
                                batch_size=getattr(self, "batch_size", None),
                                final_combine=getattr(self, "stack_final_combine", None),
                            )
                        except Exception as e_s:
                            align_method_log_msg += f"_SolveError_{type(e_s).__name__}"
                        if (
                            wcs_panel_solved_by_solver
                            and wcs_panel_solved_by_solver.is_celestial
                        ):
                            align_method_log_msg = (
                                "FastAligner_Fail_Fallback_WCS_Success"
                            )
                            wcs_final_pour_retour = wcs_panel_solved_by_solver
                            matrice_M_calculee = self._calculate_M_from_wcs(
                                wcs_panel_solved_by_solver,
                                self.reference_wcs_object,
                                image_for_alignment_or_drizzle_input.shape[:2],
                            )
                            if matrice_M_calculee is None:
                                align_method_log_msg = (
                                    "FastAligner_Fail_Fallback_WCS_Matrix_Fail"
                                )
                                wcs_final_pour_retour = None
                        else:
                            if "_SolveError_" not in align_method_log_msg:
                                align_method_log_msg = (
                                    "FastAligner_Fail_Fallback_WCS_Fail"
                                )
                            wcs_final_pour_retour = None
                            matrice_M_calculee = None
                    else:
                        align_method_log_msg = "FastAligner_Fail_Fallback_NoSolver"
                        wcs_final_pour_retour = None
                        matrice_M_calculee = None
                elif not fa_success and not self.use_wcs_fallback_for_mosaic:
                    align_method_log_msg = "FastAligner_Fail_No_Fallback"
                    wcs_final_pour_retour = None
                    matrice_M_calculee = None
                # data_final_pour_retour a déjà été mis à image_for_alignment_or_drizzle_input (ADU) si mode drizzle/mosaic

            elif (
                solve_astrometry_for_this_file
                and self.is_mosaic_run
                and self.mosaic_alignment_mode == "astrometry_per_panel"
            ):
                align_method_log_msg = "Astrometry_Per_Panel_Attempted"
                if self.astrometry_solver:
                    solver_settings_for_this_panel = {
                        "local_solver_preference": self.local_solver_preference,
                        "api_key": self.api_key,
                        "astap_path": self.astap_path,
                        "astap_data_dir": self.astap_data_dir,
                        "astap_search_radius": self.astap_search_radius,
                        "astap_downsample": self.astap_downsample,
                        "astap_sensitivity": self.astap_sensitivity,
                        "local_ansvr_path": self.local_ansvr_path,
                        "scale_est_arcsec_per_pix": self.reference_pixel_scale_arcsec,
                        "scale_tolerance_percent": 20,
                        "ansvr_timeout_sec": getattr(self, "ansvr_timeout_sec", 120),
                        "astap_timeout_sec": getattr(self, "astap_timeout_sec", 120),
                        "astrometry_net_timeout_sec": getattr(
                            self, "astrometry_net_timeout_sec", 300
                        ),
                    }
                    wcs_final_pour_retour = self.astrometry_solver.solve(
                        file_path,
                        header_final_pour_retour,
                        solver_settings_for_this_panel,
                        True,
                        batch_size=getattr(self, "batch_size", None),
                        final_combine=getattr(self, "stack_final_combine", None),
                    )
                    if wcs_final_pour_retour and wcs_final_pour_retour.is_celestial:
                        align_method_log_msg = "Astrometry_Per_Panel_Success"
                        matrice_M_calculee = np.array(
                            [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0]], dtype=np.float32
                        )
                    else:
                        align_method_log_msg = "Astrometry_Per_Panel_Fail"
                        wcs_final_pour_retour = None
                        matrice_M_calculee = None
                else:
                    align_method_log_msg = "Astrometry_Per_Panel_NoSolver"
                    wcs_final_pour_retour = None
                    matrice_M_calculee = None
                # data_final_pour_retour a déjà été mis à image_for_alignment_or_drizzle_input (ADU)
            elif solve_astrometry_for_this_file and not self.is_mosaic_run:
                align_method_log_msg = "Astrometry_Single_Attempted"
                if self.astrometry_solver:
                    solver_settings_for_file = {
                        "local_solver_preference": self.local_solver_preference,
                        "api_key": self.api_key,
                        "astap_path": self.astap_path,
                        "astap_data_dir": self.astap_data_dir,
                        "astap_search_radius": self.astap_search_radius,
                        "astap_downsample": self.astap_downsample,
                        "astap_sensitivity": self.astap_sensitivity,
                        "local_ansvr_path": self.local_ansvr_path,
                        "scale_est_arcsec_per_pix": self.reference_pixel_scale_arcsec,
                        "scale_tolerance_percent": 20,
                        "ansvr_timeout_sec": getattr(self, "ansvr_timeout_sec", 120),
                        "astap_timeout_sec": getattr(self, "astap_timeout_sec", 120),
                        "astrometry_net_timeout_sec": getattr(
                            self, "astrometry_net_timeout_sec", 300
                        ),
                    }
                    wcs_final_pour_retour = self.astrometry_solver.solve(
                        file_path,
                        header_final_pour_retour,
                        solver_settings_for_file,
                        True,
                        batch_size=getattr(self, "batch_size", None),
                        final_combine=getattr(self, "stack_final_combine", None),
                    )
                    if wcs_final_pour_retour and wcs_final_pour_retour.is_celestial:
                        align_method_log_msg = "Astrometry_Single_Success"
                    else:
                        align_method_log_msg = "Astrometry_Fail_And_Rejected"
                        self.update_progress(
                            f"   -> Échec WCS pour '{file_name}'. Image rejetée (mode haute précision).",
                            "WARN",
                        )
                        raise RuntimeError(
                            f"Échec astrométrie pour '{file_name}' et aucun fallback autorisé en mode reprojection."
                        )
                else:
                    align_method_log_msg = "Astrometry_Single_NoSolver"
                    wcs_final_pour_retour = None
                matrice_M_calculee = None
                if data_final_pour_retour is None:
                    data_final_pour_retour = (
                        image_for_alignment_or_drizzle_input.astype(np.float32)
                    )
            else:
                align_method_log_msg = "Astroalign_Standard_Attempted"
                if reference_image_data_for_alignment is None:
                    raise RuntimeError("Image de référence Astroalign manquante.")

                (
                    aligned_img_astroalign,
                    align_success_astroalign,
                ) = self.aligner._align_image(
                    image_for_alignment_or_drizzle_input,
                    reference_image_data_for_alignment,
                    file_name,
                    force_same_shape_as_ref=True,
                    use_disk=align_on_disk,
                )

                if align_success_astroalign and aligned_img_astroalign is not None:
                    align_method_log_msg = "Astroalign_Standard_Success"
                    logger.debug(
                        f"     - APRÈS ALIGNEMENT (Astroalign): aligned_img_astroalign - Range: [{np.min(aligned_img_astroalign):.4g}, {np.max(aligned_img_astroalign):.4g}], Shape: {aligned_img_astroalign.shape}, Dtype: {aligned_img_astroalign.dtype}"
                    )
                    data_final_pour_retour = aligned_img_astroalign.astype(np.float32)

                    if (
                        (self.reproject_between_batches or self.reproject_coadd_final)
                        and self.reference_wcs_object is not None
                    ):
                        # Attach the reference WCS so batches can be reprojected
                        wcs_final_pour_retour = self.reference_wcs_object

                    if not is_drizzle_or_mosaic_mode:
                        # In classic stacking mode, keep the aligned image as-is
                        pass
                    else:
                        # Pour Drizzle Standard, data_final_pour_retour est déjà aligned_img_astroalign.
                        # _align_image est censé avoir préservé la plage ADU si l'entrée était ADU.
                        logger.debug(
                            f"       - DRIZZLE STANDARD: data_final_pour_retour (venant de aligned_img_astroalign) gardé en ADU. Range: [{np.min(data_final_pour_retour):.4g}, {np.max(data_final_pour_retour):.4g}]"
                        )
                else:
                    align_method_log_msg = "Astroalign_Standard_Fail"
                    raise RuntimeError(
                        f"Échec Alignement Astroalign standard pour {file_name}."
                    )
                matrice_M_calculee = None

            header_final_pour_retour["_ALIGN_METHOD_LOG"] = (
