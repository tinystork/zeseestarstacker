                            )
                        )
                    except Exception:
                        has_accumulated = True  # be conservative

                    if self.aligned_temp_paths and has_accumulated:
                        self.update_progress(
                            "Skipping extra disk restack (batch_size=1); using accumulated SUM/W.",
                            "INFO_DETAIL",
                        )
                        # Best‑effort cleanup of temporary aligned files
                        for p in list(self.aligned_temp_paths):
                            try:
                                if os.path.isfile(p):
                                    os.remove(p)
                                hdr_p = os.path.splitext(p)[0] + ".hdr"
                                if os.path.isfile(hdr_p):
                                    os.remove(hdr_p)
                                mask_p = os.path.join(
                                    os.path.dirname(p),
                                    os.path.basename(p).replace("aligned_", "mask_").rsplit(".", 1)[0] + ".npy",
                                )
                                if os.path.isfile(mask_p):
                                    os.remove(mask_p)
                            except Exception:
                                pass
                        self.aligned_temp_paths = []
                    final_sum = np.array(self.cumulative_sum_memmap, dtype=np.float64)
                    final_wht_map_2d_from_memmap = np.array(
                        self.cumulative_wht_memmap, dtype=np.float32
                    )
                else:
                    final_sum = np.array(self.cumulative_sum_memmap, dtype=np.float64)
                    final_wht_map_2d_from_memmap = np.array(
                        self.cumulative_wht_memmap, dtype=np.float32
                    )
                if "final_sum" in locals():
                    self.update_progress(
                        f"    DEBUG QM: Classic Mode - final_sum (HWC, from memmap) - Shape: {final_sum.shape}, Range: [{np.nanmin(final_sum):.4g} - {np.nanmax(final_sum):.4g}]"
                    )
                    logger.debug(
                        f"    DEBUG QM: Classic Mode - final_sum (HWC, from memmap) - Shape: {final_sum.shape}, Range: [{np.nanmin(final_sum):.4g} - {np.nanmax(final_sum):.4g}]"
                    )
                    self.update_progress(
                        f"    DEBUG QM: Classic Mode - final_wht_map_2d_from_memmap (HW) - Shape: {final_wht_map_2d_from_memmap.shape}, Range: [{np.nanmin(final_wht_map_2d_from_memmap):.4g} - {np.nanmax(final_wht_map_2d_from_memmap):.4g}]"
                    )
                    logger.debug(
                        f"    DEBUG QM: Classic Mode - final_wht_map_2d_from_memmap (HW) - Shape: {final_wht_map_2d_from_memmap.shape}, Range: [{np.nanmin(final_wht_map_2d_from_memmap):.4g} - {np.nanmax(final_wht_map_2d_from_memmap):.4g}]"
                    )

                if "final_sum" in locals():
                    self._close_memmaps()

                    eps = 1e-9
                    final_wht_map_for_postproc = np.maximum(
                        final_wht_map_2d_from_memmap, 0.0
                    )
                    with np.errstate(divide="ignore", invalid="ignore"):
                        final_image_initial_raw = final_sum / np.maximum(
                            final_wht_map_2d_from_memmap[..., None], eps
                        )
                    final_image_initial_raw = np.nan_to_num(
                        final_image_initial_raw, nan=0.0, posinf=0.0, neginf=0.0
                    )
                    final_image_initial_raw = final_image_initial_raw.astype(np.float32)
                    self.update_progress(
                        f"    DEBUG QM: Classic Mode - final_image_initial_raw (HWC, après SUM/WHT et nan_to_num) - Range: [{np.nanmin(final_image_initial_raw):.4g} - {np.nanmax(final_image_initial_raw):.4g}]"
                    )
                    logger.debug(
                        f"    DEBUG QM: Classic Mode - final_image_initial_raw (HWC, après SUM/WHT et nan_to_num) - Range: [{np.nanmin(final_image_initial_raw):.4g} - {np.nanmax(final_image_initial_raw):.4g}]"
                    )

        except Exception as e_get_raw:
            self.processing_error = (
                f"Erreur obtention donnees brutes finales: {e_get_raw}"
            )
            self.update_progress(f"❌ {self.processing_error}", "ERROR")
            traceback.print_exc(limit=2)
            self.final_stacked_path = None
            return

        if final_image_initial_raw is None:
            self.final_stacked_path = None
            self.update_progress("ⓘ Aucun stack final (donnees brutes sont None).")
            return

        # À ce stade, final_image_initial_raw contient les données "ADU-like"
        self.update_progress(
            f"  DEBUG QM [SaveFinalStack] final_image_initial_raw (AVANT post-traitements) - Range: [{np.nanmin(final_image_initial_raw):.4g}, {np.nanmax(final_image_initial_raw):.4g}], Shape: {final_image_initial_raw.shape}, Dtype: {final_image_initial_raw.dtype}"
        )
        logger.debug(
            f"  DEBUG QM [SaveFinalStack] final_image_initial_raw (AVANT post-traitements) - Range: [{np.nanmin(final_image_initial_raw):.4g}, {np.nanmax(final_image_initial_raw):.4g}], Shape: {final_image_initial_raw.shape}, Dtype: {final_image_initial_raw.dtype}"
        )

        if final_wht_map_for_postproc is not None:
            rows, cols = np.where(final_wht_map_for_postproc > 0)
            if rows.size and cols.size:
                y0, y1 = rows.min(), rows.max() + 1
                x0, x1 = cols.min(), cols.max() + 1
                if final_image_initial_raw.ndim == 3:
                    final_image_initial_raw = final_image_initial_raw[y0:y1, x0:x1, :]
                else:
                    final_image_initial_raw = final_image_initial_raw[y0:y1, x0:x1]
                final_wht_map_for_postproc = final_wht_map_for_postproc[y0:y1, x0:x1]
                if self.current_stack_header:
                    if "CRPIX1" in self.current_stack_header:
                        self.current_stack_header["CRPIX1"] -= x0
                    if "CRPIX2" in self.current_stack_header:
                        self.current_stack_header["CRPIX2"] -= y0
                if self.drizzle_output_wcs is not None:
                    try:
                        self.drizzle_output_wcs.wcs.crpix = [
                            self.drizzle_output_wcs.wcs.crpix[0] - x0,
                            self.drizzle_output_wcs.wcs.crpix[1] - y0,
                        ]
                        new_w = x1 - x0
                        new_h = y1 - y0
                        self.drizzle_output_wcs.pixel_shape = (new_w, new_h)
                        self.drizzle_output_wcs._naxis1 = new_w
                        self.drizzle_output_wcs._naxis2 = new_h
                    except Exception:
                        pass

        final_image_initial_raw = final_image_initial_raw.astype(np.float32)
        if not preserve_linear_output_setting:
            final_image_initial_raw = np.clip(final_image_initial_raw, 0.0, None)
        self.update_progress(
            f"    DEBUG QM: Après clip >=0 des valeurs négatives, final_image_initial_raw - Range: [{np.nanmin(final_image_initial_raw):.4g}, {np.nanmax(final_image_initial_raw):.4g}]"
        )
        logger.debug(
            f"    DEBUG QM: Après clip >=0 des valeurs négatives, final_image_initial_raw - Range: [{np.nanmin(final_image_initial_raw):.4g}, {np.nanmax(final_image_initial_raw):.4g}]"
        )

        # Appliquer le seuil WHT (si activé) aux données "ADU-like"
        if self.drizzle_wht_threshold > 0 and final_wht_map_for_postproc is not None:
            self.update_progress(
                f"  DEBUG QM [SaveFinalStack] Application du seuil WHT ({self.drizzle_wht_threshold}) sur final_wht_map_for_postproc à final_image_initial_raw."
            )
            logger.debug(
                f"  DEBUG QM [SaveFinalStack] Application du seuil WHT ({self.drizzle_wht_threshold}) sur final_wht_map_for_postproc à final_image_initial_raw."
            )
            invalid_wht_pixels = final_wht_map_for_postproc < self.drizzle_wht_threshold
            if final_image_initial_raw.ndim == 3:
                final_image_initial_raw = np.where(
                    invalid_wht_pixels[..., np.newaxis], np.nan, final_image_initial_raw
                )
            else:
                final_image_initial_raw = np.where(
                    invalid_wht_pixels, np.nan, final_image_initial_raw
                )

        # Stocker les données ADU pour histogramme UI uniquement si nécessaire
        self.raw_adu_data_for_ui_histogram = (
            np.nan_to_num(final_image_initial_raw, nan=0.0).astype(np.float32).copy()
        )
        logger.debug(
            f"  DEBUG QM [_save_final_stack]: self.raw_adu_data_for_ui_histogram STOCKE (ADU). Range: [{np.min(self.raw_adu_data_for_ui_histogram):.3f}, {np.max(self.raw_adu_data_for_ui_histogram):.3f}]"
        )

        # --- Normalisation par percentiles pour obtenir final_image_normalized_for_cosmetics (0-1) ---
        if preserve_linear_output_setting:
            logger.debug(
                "  DEBUG QM [_save_final_stack]: preserve_linear_output actif - saut de la normalisation par percentiles."
            )
            final_image_normalized_for_cosmetics = np.nan_to_num(
                final_image_initial_raw, nan=0.0
            ).astype(np.float32)
        else:
            logger.debug(
                f"  DEBUG QM [_save_final_stack]: Normalisation (0-1) par percentiles de final_image_initial_raw..."
            )
            data_for_percentile_norm = np.nan_to_num(
                final_image_initial_raw, nan=0.0
            ).astype(np.float32)
            if data_for_percentile_norm.ndim == 3:
                luminance = (
                    0.299 * data_for_percentile_norm[..., 0]
                    + 0.587 * data_for_percentile_norm[..., 1]
                    + 0.114 * data_for_percentile_norm[..., 2]
                )
            else:
                luminance = data_for_percentile_norm
            finite_luminance = luminance[np.isfinite(luminance) & (luminance > 1e-9)]

            if finite_luminance.size > 20:
                bp_val = np.percentile(finite_luminance, 0.1)
                wp_val = np.percentile(finite_luminance, 99.9)
                if wp_val <= bp_val + 1e-7:
                    min_finite, max_finite = np.min(finite_luminance), np.max(
                        finite_luminance
                    )
                    if max_finite > min_finite + 1e-7:
                        bp_val, wp_val = min_finite, max_finite
                    else:
                        bp_val, wp_val = 0.0, max(1e-7, max_finite)
                if wp_val <= bp_val:
                    wp_val = bp_val + 1e-7
                final_image_normalized_for_cosmetics = (
                    data_for_percentile_norm - bp_val
                ) / (wp_val - bp_val)
                logger.debug(
                    f"  DEBUG QM [_save_final_stack]: Normalisation (0-1) basée sur percentiles. BP={bp_val:.4g}, WP={wp_val:.4g}."
                )
            else:
                max_overall = np.nanmax(data_for_percentile_norm)
                if max_overall > 1e-9:
                    final_image_normalized_for_cosmetics = (
                        data_for_percentile_norm / max_overall
                    )
                else:
                    final_image_normalized_for_cosmetics = np.zeros_like(
                        data_for_percentile_norm
                    )
                logger.debug(
                    "  DEBUG QM [_save_final_stack]: Normalisation (0-1) par max (peu de données/dynamique pour percentiles)."
                )

            final_image_normalized_for_cosmetics = np.clip(
                final_image_normalized_for_cosmetics, 0.0, 1.0
            )

        final_image_normalized_for_cosmetics = (
            final_image_normalized_for_cosmetics.astype(np.float32)
        )
        logger.debug(
            f"    Range après normalisation (0-1): [{np.nanmin(final_image_normalized_for_cosmetics):.3f}, {np.nanmax(final_image_normalized_for_cosmetics):.3f}]"
        )

        effective_image_count = self.images_in_cumulative_stack

        # data_after_postproc est la version 0-1 qui subira les post-traitements cosmétiques.
