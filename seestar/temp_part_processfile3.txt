                # Pour la logique de mosaïque locale, path_of_processed_ref_panel_basename
                # doit aussi être juste le nom de base.
                if use_local_aligner_for_this_mosaic_run:
                    path_of_processed_ref_panel_basename = source_basename_for_wcs_ref
                    logger.debug(
                        f"DEBUG QM [_worker]: Panneau d'ancre identifié par basename: {path_of_processed_ref_panel_basename}"
                    )
            else:
                # Si _SOURCE_PATH n'est pas dans le header de reference_image.fit, on ne peut pas le définir
                # Cela pourrait arriver si _get_reference_image ne l'ajoute pas.
                logger.debug(
                    "WARN QM [_worker]: Mot-clé '_SOURCE_PATH' non trouvé dans le header de l'image de référence globale."
                )
                if use_local_aligner_for_this_mosaic_run:
                    path_of_processed_ref_panel_basename = (
                        "unknown_reference_panel.fits"  # Fallback
                    )

            ref_temp_processing_dir = os.path.join(
                self.output_folder, "temp_processing"
            )
            reference_image_path_for_solver = os.path.join(
                ref_temp_processing_dir, "reference_image.fit"
            )

            # À ce stade, reference_image.fit doit exister, sinon l'erreur que tu as eue se produira.
            if not os.path.exists(reference_image_path_for_solver):
                # Cette erreur devrait être prévenue si _get_reference_image fonctionne correctement
                # ET si la correction pour _SOURCE_PATH trop long est appliquée DANS _get_reference_image.
                raise RuntimeError(
                    f"CRITICAL: Fichier de référence '{reference_image_path_for_solver}' non trouvé après appel à _get_reference_image. Vérifier la logique de sauvegarde dans SeestarAligner._get_reference_image pour les headers longs."
                )

            logger.debug(
                f"DEBUG QM [_worker]: Image de référence de base (pour shape et solving) prête: {reference_image_path_for_solver}"
            )

            # --- 1.A Plate-solving de la référence ---
            if (
                self.drizzle_active_session
                or self.is_mosaic_run
                or self.reproject_between_batches
                or self.reproject_coadd_final
            ):
                self.update_progress(
                    "DEBUG WORKER: Section 1.A - Plate-solving de la référence..."
                )
            else:
                logger.debug(
                    "DEBUG QM [_worker]: Plate-solving de la référence ignoré (mode Stacking Classique sans reprojection)."
                )
            # Éviter d'écraser un WCS déjà déterminé. On se contente de
            # réinitialiser si aucun WCS valide n'est présent.
            if not (
                self.reproject_between_batches and self.freeze_reference_wcs
            ) and not (
                self.reference_wcs_object
                and getattr(self.reference_wcs_object, "is_celestial", False)
            ):
                self.reference_wcs_object = None
            # Temporaire pour la logique mosaïque locale ; peut être prérempli
            # avec un WCS existant si disponible.
            temp_wcs_ancre = (
                self.reference_wcs_object
                if self.reference_wcs_object
                and getattr(self.reference_wcs_object, "is_celestial", False)
                else None
            )

            logger.debug(f"!!!! DEBUG _WORKER AVANT CRÉATION DICT SOLVEUR ANCRE !!!!")
            logger.debug(f"    self.is_mosaic_run = {self.is_mosaic_run}")
            logger.debug(
                f"    self.local_solver_preference = '{getattr(self, 'local_solver_preference', 'NON_DÉFINI')}'"
            )
            logger.debug(
                f"    self.astap_search_radius = {getattr(self, 'astap_search_radius', 'NON_DÉFINI')}"
            )
            logger.debug(
                f"    self.reference_pixel_scale_arcsec = {self.reference_pixel_scale_arcsec}"
            )

            solver_settings_for_ref_anchor = {
                "local_solver_preference": self.local_solver_preference,
                "api_key": self.api_key,
                "astap_path": self.astap_path,
                "astap_data_dir": self.astap_data_dir,
                "astap_search_radius": self.astap_search_radius,
                "astap_downsample": self.astap_downsample,
                "astap_sensitivity": self.astap_sensitivity,
                "local_ansvr_path": self.local_ansvr_path,
                "scale_est_arcsec_per_pix": self.reference_pixel_scale_arcsec,  # Peut être None au premier passage
                "scale_tolerance_percent": 20,
                "ansvr_timeout_sec": getattr(self, "ansvr_timeout_sec", 120),
                "astap_timeout_sec": getattr(self, "astap_timeout_sec", 120),
                "astrometry_net_timeout_sec": getattr(
                    self, "astrometry_net_timeout_sec", 300
                ),
                # Hints can dramatically speed ASTAP when RA/DEC are present
                "use_radec_hints": False,
            }
            # (Vos logs pour le contenu de solver_settings_for_ref_anchor peuvent rester ici)
            logger.debug(
                f"DEBUG QM (_worker): Contenu de solver_settings_for_ref_anchor:"
            )
            for key_s, val_s in solver_settings_for_ref_anchor.items():
                if key_s == "api_key":
                    logger.debug(
                        f"    '{key_s}': '{'Présente' if val_s else 'Absente'}'"
                    )
                else:
                    logger.debug(f"    '{key_s}': '{val_s}'")

            logger.debug(
                f"!!!! DEBUG _worker AVANT BLOC IF/ELIF POUR SOLVING ANCRE (SECTION 1.A) !!!! self.is_mosaic_run = {self.is_mosaic_run}"
            )

            # --- CAS 1: Mosaïque Locale (FastAligner avec ou sans fallback WCS) ---
            if (
                use_local_aligner_for_this_mosaic_run
            ):  # Flag défini au tout début de _worker
                self.update_progress(
                    "⭐ Mosaïque Locale: Traitement du panneau de référence (ancrage)..."
                )
                mosaic_ref_panel_image_data = reference_image_data_for_global_alignment
                mosaic_ref_panel_header = self.reference_header_for_wcs.copy()

                if reference_header_for_global_alignment.get("_SOURCE_PATH"):
                    # path_of_processed_ref_panel_basename est déjà défini plus haut
                    mosaic_ref_panel_header["_PANREF_FN"] = (
                        path_of_processed_ref_panel_basename,
                        "Base name of this mosaic ref panel source",
                    )

                if temp_wcs_ancre is not None:
                    self.update_progress(
                        "   -> Mosaïque Locale: WCS de référence déjà présent. Solving ignoré.",
                        "INFO_DETAIL",
                    )
                elif self.astrometry_solver and os.path.exists(
                    reference_image_path_for_solver
                ):
                    self.update_progress(
                        "   -> Mosaïque Locale: Tentative résolution astrométrique ancre via self.astrometry_solver.solve..."
                    )
                    temp_wcs_ancre = self._solve_astrometry_async(
                        reference_image_path_for_solver,
                        mosaic_ref_panel_header,
                        solver_settings_for_ref_anchor,
                        update_header_with_solution=True,
                        progress_message="   -> Mosaïque Locale: Résolution astrométrique en cours...",
                    )
                    if temp_wcs_ancre:
                        self.update_progress(
                            "   -> Mosaïque Locale: Astrometry (via solveur) ancre RÉUSSI."
                        )
                    else:
                        self.update_progress(
                            "   -> Mosaïque Locale: Astrometry (via solveur) ancre ÉCHOUÉ."
                        )
                else:
                    self.update_progress(
                        "   -> Mosaïque Locale: AstrometrySolver non dispo ou fichier réf. manquant. Solving ancre impossible.",
                        "ERROR",
                    )

                if temp_wcs_ancre is None:
                    self.update_progress(
                        "   ⚠️ Échec de tous les solveurs pour panneau de référence. Tentative WCS approximatif (fallback)..."
                    )
                    _cwfh_func = None
                    from ..enhancement.drizzle_integration import (
                        _create_wcs_from_header as _cwfh,
                    )

                    _cwfh_func = _cwfh
                    if _cwfh_func:
                        temp_wcs_ancre = _cwfh_func(mosaic_ref_panel_header)
                    if temp_wcs_ancre and temp_wcs_ancre.is_celestial:
                        nx_hdr_a = mosaic_ref_panel_header.get("NAXIS1")
                        ny_hdr_a = mosaic_ref_panel_header.get("NAXIS2")
                        if nx_hdr_a and ny_hdr_a:
                            temp_wcs_ancre.pixel_shape = (int(nx_hdr_a), int(ny_hdr_a))
                        elif hasattr(mosaic_ref_panel_image_data, "shape"):
                            temp_wcs_ancre.pixel_shape = (
                                mosaic_ref_panel_image_data.shape[1],
                                mosaic_ref_panel_image_data.shape[0],
                            )

                if temp_wcs_ancre is None:
                    raise RuntimeError(
                        "Mosaïque Locale: Échec critique obtention WCS pour panneau de référence."
                    )
                self.reference_wcs_object = temp_wcs_ancre

                if self.reference_wcs_object:
                    try:
                        scale_deg = np.mean(
                            np.abs(
                                proj_plane_pixel_scales(self.reference_wcs_object)
                            )
                        )
                        arcsec_raw = scale_deg * 3600.0
                        if arcsec_raw < 0.1 or arcsec_raw > 30.0:
                            logger.warning(
                                "Reference WCS pixel scale %.3f arcsec/pix outside [0.1, 30.0]; clipping.",
                                arcsec_raw,
                            )
                        self.reference_pixel_scale_arcsec = float(
                            np.clip(arcsec_raw, 0.1, 30.0)
                        )
                    except Exception:
                        pass  # Ignorer si erreur de calcul

                if self.reference_wcs_object:
                    logger.debug(
                        f"  DEBUG QM [_worker]: Infos WCS du Panneau d'Ancrage (self.reference_wcs_object): CRVAL={self.reference_wcs_object.wcs.crval if self.reference_wcs_object.wcs else 'N/A'} ..."
                    )

                mat_identite_ref_panel = np.array(
                    [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0]], dtype=np.float32
                )
                valid_mask_ref_panel_pixels = np.ones(
                    mosaic_ref_panel_image_data.shape[:2], dtype=bool
                )
                all_aligned_files_with_info_for_mosaic.append(
                    (
                        mosaic_ref_panel_image_data.copy(),
                        mosaic_ref_panel_header.copy(),
                        self.reference_wcs_object,
                        mat_identite_ref_panel,
                        valid_mask_ref_panel_pixels,
                    )
                )
                self.aligned_files_count += 1
                self._increment_aligned_counter()
                self.processed_files_count += 1
                logger.debug(
                    f"DEBUG QM [_worker]: Mosaïque Locale: Panneau de référence ajouté à all_aligned_files_with_info_for_mosaic."
                )

            # --- CAS 2: Mosaïque Astrometry.net par panneau, Drizzle Standard ou Reprojection entre lots ---
            elif (
                self.drizzle_active_session
                or use_astrometry_per_panel_mosaic
                or self.reproject_between_batches
                or self.reproject_coadd_final
            ):  # `use_astrometry_per_panel_mosaic` est True si mode mosaique="astrometry_per_panel"
                self.update_progress(
                    "DEBUG WORKER: Branche Drizzle Std / AstroMosaic / ReprojectBatches pour référence globale..."
                )

                if (
                    self.reproject_between_batches
                    and not self.freeze_reference_wcs
                    and not self.drizzle_active_session
                    and not self.is_mosaic_run
                ):
                    self.update_progress(
                        "   -> Reproject entre lots actif: résolution de la référence reportée au premier stack",
                        "INFO_DETAIL",
                    )
                    self.reference_wcs_object = None
                elif self.astrometry_solver and os.path.exists(
                    reference_image_path_for_solver
                ):
                    # Éviter un double plate-solving si un WCS de référence est déjà présent
                    if (
                        getattr(self, "reference_wcs_object", None) is not None
                        and getattr(self.reference_wcs_object, "is_celestial", False)
                    ):
                        self.update_progress(
                            "   -> Drizzle Std/AstroMosaic: WCS de référence déjà présent. Solving ignoré.",
                            "INFO_DETAIL",
                        )
                    else:
                        self.update_progress(
                            "   -> Drizzle Std/AstroMosaic: Tentative résolution astrométrique réf. globale via self.astrometry_solver.solve..."
                        )
                        self.reference_wcs_object = self._solve_astrometry_async(
                            reference_image_path_for_solver,
                            self.reference_header_for_wcs,
                            solver_settings_for_ref_anchor,
                            update_header_with_solution=True,
                            progress_message="   -> Drizzle Std/AstroMosaic: Résolution astrométrique en cours...",
                        )
                else:
                    self.update_progress(
                        "   -> Drizzle Std/AstroMosaic: AstrometrySolver non dispo ou fichier réf. manquant. Solving réf. globale impossible.",
                        "ERROR",
                    )
                    self.reference_wcs_object = None

                if self.reference_wcs_object is None:  # Si solving a échoué
                    self.update_progress(
                        "ERREUR WORKER: Échec plate-solving réf. principale (Drizzle Std / AstroMosaic). Tentative WCS approximatif...",
                        "WARN",
                    )
                    # Fallback WCS approximatif pour Drizzle Standard / Mosaïque Astrometry.net per Panel
                    _cwfh_func_std_driz = None
                    from ..enhancement.drizzle_integration import (
                        _create_wcs_from_header as _cwfh_std,
                    )

                    _cwfh_func_std_driz = _cwfh_std
                    if _cwfh_func_std_driz:
                        self.reference_wcs_object = _cwfh_func_std_driz(
                            self.reference_header_for_wcs
                        )
                    if not (
                        self.reference_wcs_object
                        and self.reference_wcs_object.is_celestial
                    ):
                        raise RuntimeError(
                            "Échec critique obtention WCS pour Drizzle standard ou Mosaïque Astrometry (même après fallback)."
                        )
                    self.update_progress(
                        "   -> WCS approximatif pour réf. globale créé (pour Drizzle Std / AstroMosaic).",
                        "INFO",
                    )

