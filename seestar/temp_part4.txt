    except Exception:
        scores["snr"] = 0.0

    # --- Calculate Star Count ---
    try:
        transform, (source_list, _target_list) = aa.find_transform(
            image_data, image_data
        )
        num_stars = len(source_list)
        max_stars_for_score = 200.0
        scores["stars"] = float(np.clip(num_stars / max_stars_for_score, 0.0, 1.0))
    except (aa.MaxIterError, ValueError) as star_err:
        star_msg = (
            f"Warning: Failed finding stars ({type(star_err).__name__}). "
            "Stars score set to 0."
        )
        scores["stars"] = 0.0
    except Exception as e:
        star_msg = f"Error calculating stars: {e}. Stars score set to 0."
        scores["stars"] = 0.0

    return scores, star_msg, num_stars


def get_batches_from_stack_plan(plan_path, input_folder=None):
    """Read ``stack_plan.csv`` and group file paths by ``batch_id``.

    Parameters
    ----------
    plan_path : str
        Path to the CSV plan file.
    input_folder : str, optional
        Folder used to rebase relative or invalid paths.

    Returns
    -------
    list[list[str]]
        Ordered list of batches. Each batch is a list of file paths.
    """

    batches = []
    by_batch: dict[str, list[str]] = {}
    with open(plan_path, newline="", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        for row in reader:
            batch_id = row.get("batch_id")
            file_path = row.get("file_path")
            if not file_path or batch_id is None:
                continue
            if input_folder and not os.path.isfile(file_path):
                file_path = os.path.join(input_folder, os.path.basename(file_path))
            by_batch.setdefault(batch_id, []).append(file_path)

    batch_order = []
    with open(plan_path, newline="", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        for row in reader:
            batch_id = row.get("batch_id")
            if batch_id not in batch_order:
                batch_order.append(batch_id)

    for bid in batch_order:
        batches.append(by_batch.get(bid, []))

    return batches


# --- Optional Third-Party Imports (with availability flags) ---
try:
    # On importe juste Drizzle ici, car la CLASSE est utilisée dans les méthodes
    from drizzle.resample import Drizzle

    _OO_DRIZZLE_AVAILABLE = True
    logger.debug("Import drizzle.resample.Drizzle OK.")
except ImportError as e_driz_cls:
    _OO_DRIZZLE_AVAILABLE = False
    Drizzle = None  # Définir comme None si indisponible
    logger.error("Échec import drizzle.resample.Drizzle: %s", e_driz_cls)


# --- Core/Internal Imports (Needed for __init__ or core logic) ---
try:
    from ..core.hot_pixels import detect_and_correct_hot_pixels
except ImportError as e:
    logger.error("Échec import detect_and_correct_hot_pixels: %s", e)
    raise
try:
    from ..core.image_processing import (
        debayer_image,
        load_and_validate_fits,
        save_fits_image,
        save_preview_image,
    )
except ImportError as e:
    logger.error("Échec import image_processing: %s", e)
    raise
try:
    from ..core.utils import estimate_batch_size
except ImportError as e:
    logger.error("Échec import utils: %s", e)
    raise
try:
    from ..enhancement.color_correction import ChromaticBalancer
except ImportError as e_cb:
    logger.error("Échec import ChromaticBalancer: %s", e_cb)
    raise

# --- Imports INTERNES à déplacer en IMPORTS TARDIFS (si utilisés uniquement dans des méthodes spécifiques) ---
# Ces modules/fonctions sont gérés par des appels conditionnels ou try/except dans les méthodes où ils sont utilisés.
# from ..enhancement.drizzle_integration import _load_drizzle_temp_file, DrizzleProcessor, _create_wcs_from_header
# from ..alignment.astrometry_solver import solve_image_wcs
# from ..enhancement.mosaic_processor import process_mosaic_from_aligned_files
# from ..enhancement.stack_enhancement import StackEnhancer # Cette classe n'est pas utilisée ici

# --- Configuration des Avertissements ---
warnings.filterwarnings("ignore", category=FITSFixedWarning)
logger.debug("Configuration warnings OK.")
# --- FIN Imports ---
# --- NEW GLOBAL VERSION STRING CONSTANT (ajoutée à la fin de queue_manager.py) ---
# Assurez-vous d'ajouter cette ligne aussi à l'extérieur de la classe, tout en haut du fichier, comme je l'ai suggéré précédemment.
# Global version string to make sure it's always the same
GLOBAL_DRZ_BATCH_VERSION_STRING_ULTRA_DEBUG = "v6.6.2 Boring"

# --- Internal Project Imports (Core Modules ABSOLUMENT nécessaires pour la classe/init) ---
# Core Alignment (Instancié dans __init__)
try:
    from ..core.alignment import SeestarAligner

    logger.debug("Import SeestarAligner OK.")
except ImportError as e:
    logger.error("Échec import SeestarAligner: %s", e)
    raise
# Core Hot Pixels (Utilisé dans _worker -> _process_file)
try:
    from ..core.hot_pixels import detect_and_correct_hot_pixels

    logger.debug("Import detect_and_correct_hot_pixels OK.")
except ImportError as e:
    logger.error("Échec import detect_and_correct_hot_pixels: %s", e)
    raise
# Core Image Processing (Utilisé PARTOUT)
try:
    from ..core.image_processing import (
        debayer_image,
        load_and_validate_fits,
        save_fits_image,
        save_preview_image,
    )

    logger.debug("Imports image_processing OK.")
except ImportError as e:
    logger.error("Échec import image_processing: %s", e)
    raise
# --- IMPORT POUR L'ALIGNEUR LOCAL ---
try:
    from ..core import SeestarLocalAligner  # Devrait être FastSeestarAligner aliasé

    _LOCAL_ALIGNER_AVAILABLE = True
    logger.debug("Import SeestarLocalAligner (local CV) OK.")
except ImportError:
    _LOCAL_ALIGNER_AVAILABLE = False
    SeestarLocalAligner = (
        None  # Définir pour que le code ne plante pas à l'instanciation
    )
    logger.warning(
        "SeestarLocalAligner (local CV) non importable. Alignement mosaïque local désactivé."
    )
# ---  ---


# Core Utils (Utilisé PARTOUT)
try:
    from ..core.utils import estimate_batch_size

    logger.debug("Imports utils OK.")
except ImportError as e:
    logger.error("Échec import utils: %s", e)
    raise
# Enhancement Color Correction (Instancié dans __init__)
try:
    from ..enhancement.color_correction import ChromaticBalancer

    logger.debug("Import ChromaticBalancer OK.")
except ImportError as e:
    logger.error("Échec import ChromaticBalancer: %s", e)
    raise

try:
    from ..enhancement.stack_enhancement import feather_by_weight_map  # NOUVEL IMPORT

    _FEATHERING_AVAILABLE = True
    logger.debug("Import feather_by_weight_map depuis stack_enhancement OK.")
except ImportError as e_feather:
    _FEATHERING_AVAILABLE = False
    logger.error(
        "Échec import feather_by_weight_map depuis stack_enhancement: %s",
        e_feather,
    )
    # Définir une fonction factice pour que le code ne plante pas si l'import échoue
    # lors des appels ultérieurs, bien qu'on vérifiera _FEATHERING_AVAILABLE.
