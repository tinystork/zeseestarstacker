            )
            final_wht_map_HWC = np.maximum(
                final_wht_map_HWC, 0.0
            )  # Poids doivent être >= 0

            self.update_progress(
                f"   -> Assemblage final Drizzle terminé (Shape Sci HWC: {final_sci_image_HWC.shape}, Wht HWC: {final_wht_map_HWC.shape})"
            )
            self.images_in_cumulative_stack = (
                total_contributing_ninputs_for_final_header
            )
        except Exception as e_final_asm:
            self.update_progress(
                f"   - ERREUR pendant assemblage final Drizzle: {e_final_asm}", "ERROR"
            )
            final_sci_image_HWC = None
            final_wht_map_HWC = None
        finally:
            del final_drizzlers, final_output_images_list, final_output_weights_list
            gc.collect()

        logger.debug("=" * 70 + "\n")
        return final_sci_image_HWC, final_wht_map_HWC

    def _run_astap_and_update_header(self, fits_path: str) -> bool:
        """Solve the provided FITS with the configured solver and update its header."""
        try:
            header = fits.getheader(fits_path)
        except Exception as e:
            self.update_progress(f"   [Solver] Échec lecture header: {e}", "ERROR")
            return False

        solver_settings = {
            "local_solver_preference": getattr(self, "local_solver_preference", "none"),
            "api_key": getattr(self, "api_key", ""),
            "astap_path": getattr(self, "astap_path", ""),
            "astap_data_dir": getattr(self, "astap_data_dir", ""),
            "astap_search_radius": getattr(self, "astap_search_radius", 3.0),
            "astap_downsample": getattr(self, "astap_downsample", 1),
            "astap_sensitivity": getattr(self, "astap_sensitivity", 100),
            "local_ansvr_path": getattr(self, "local_ansvr_path", ""),
            "scale_est_arcsec_per_pix": getattr(
                self, "reference_pixel_scale_arcsec", None
            ),
            "scale_tolerance_percent": 20,
            "ansvr_timeout_sec": getattr(self, "ansvr_timeout_sec", 120),
            "astap_timeout_sec": getattr(self, "astap_timeout_sec", 120),
            "astrometry_net_timeout_sec": getattr(
                self, "astrometry_net_timeout_sec", 300
            ),
            "use_radec_hints": getattr(self, "use_radec_hints", False),
        }

        # In Reproject & Coadd mode we now forward the user configured ASTAP
        # options without forcing a blind search or RA/DEC hints.  This mirrors
        # the simpler invocation used in ZeMosaic.

        self.update_progress(f"   [Solver] Solve {os.path.basename(fits_path)}…")
        if self.astrometry_solver:
            wcs = self.astrometry_solver.solve(
                fits_path,
                header,
                solver_settings,
                update_header_with_solution=True,
                batch_size=getattr(self, "batch_size", None),
                final_combine=getattr(self, "stack_final_combine", None),
            )
        else:
            wcs = solve_image_wcs(
                fits_path,
                header,
                solver_settings,
                update_header_with_solution=True,
                batch_size=getattr(self, "batch_size", None),
                final_combine=getattr(self, "stack_final_combine", None),
            )
        if wcs is None:
            self.update_progress("   [Solver] Échec résolution", "WARN")
            return False
        try:
            with fits.open(fits_path, mode="update") as hdul:
                hdul[0].header = header
                hdul.flush()
        except Exception as e:
            self.update_progress(f"   [Solver] Erreur écriture header: {e}", "WARN")
        return True

    def _cache_solved_image(self, data, header, wcs_obj, idx):
        """Cache solved image data to a temporary FITS and return the path."""
        cache_dir = os.path.join(self.output_folder, "reproj_cache")
        os.makedirs(cache_dir, exist_ok=True)
        cache_path = os.path.join(cache_dir, f"solved_{idx:05d}.fits")
        hdr = header.copy()
        if wcs_obj is not None:
            try:
                hdr.update(wcs_obj.to_header())
            except Exception:
                pass
        data_to_save = np.moveaxis(data, -1, 0) if data.ndim == 3 else data
        fits.PrimaryHDU(data=data_to_save.astype(np.float32), header=hdr).writeto(
            cache_path, overwrite=True
        )
        return cache_path

    def _solve_cumulative_stack(self):
        """Solve the current cumulative stack with ASTAP and update reference WCS."""

        if (
            self.cumulative_sum_memmap is None
            or self.cumulative_wht_memmap is None
            or self.reference_header_for_wcs is None
        ):
            return None, None

        sum_arr = np.array(self.cumulative_sum_memmap, dtype=np.float32)
        wht_arr = np.array(self.cumulative_wht_memmap, dtype=np.float32)
        with np.errstate(divide="ignore", invalid="ignore"):
            wht_safe = np.maximum(wht_arr, 1e-6)
            stack = np.nan_to_num(sum_arr / wht_safe[:, :, np.newaxis])

        hdr = self.reference_header_for_wcs.copy()

        # If the reference WCS is frozen and already defined, skip solving
        # additional stacked batches and simply return the current stack using
        # the existing reference header.
        if self.freeze_reference_wcs and self.reference_wcs_object is not None:
            self.reference_header_for_wcs = hdr.copy()
            self.ref_wcs_header = hdr.copy()
            logger.debug(
                "DEBUG QM [_solve_cumulative_stack]: Skipping ASTAP solve (freeze_reference_wcs)."
            )
            return stack.astype(np.float32), hdr

        tmp = tempfile.NamedTemporaryFile(suffix=".fits", delete=False)
        tmp.close()
        fits.PrimaryHDU(data=np.moveaxis(stack, -1, 0), header=hdr).writeto(
            tmp.name, overwrite=True
        )
        solved_ok = self._run_astap_and_update_header(tmp.name)
        if solved_ok:
            hdr = fits.getheader(tmp.name)
        os.remove(tmp.name)

        try:
            new_wcs = WCS(hdr, naxis=2)
            new_wcs.pixel_shape = (
                stack.shape[1],
                stack.shape[0],
            )
        except Exception:
            new_wcs = None

        if self.reference_wcs_object is None or not self.freeze_reference_wcs:
            if new_wcs is not None:
                self.reference_wcs_object = new_wcs

        self.reference_header_for_wcs = hdr.copy()
        self.ref_wcs_header = hdr.copy()

        return stack.astype(np.float32), hdr

    def _load_and_prepare_simple(self, fits_path: str):
        data = _fits_getdata_safe(fits_path, memmap=True).astype(np.float32, copy=False)
        hdr = fits.getheader(fits_path)
        try:
            input_wcs = WCS(hdr, naxis=2)
        except Exception:
