                    "‚ö†Ô∏è Aucun fichier initial trouv√© dans le dossier principal et aucun dossier suppl√©mentaire en attente."
                )

        if (
            self._resume_requested
            and self.stacked_batches_count > 0
            and self.batch_size > 0
        ):
            skip_files = self.stacked_batches_count * self.batch_size
            skipped = 0
            while skipped < skip_files and not self.queue.empty():
                try:
                    self.queue.get_nowait()
                    skipped += 1
                except Empty:
                    break
            if skipped:
                self.files_in_queue = max(self.files_in_queue - skipped, 0)
                self._recalculate_total_batches()
                self.update_progress(f"Resuming: {skipped} fichiers ignor√©s.")

        if self.is_mosaic_run and self.reproject_between_batches:
            ok_grid = self._prepare_global_reprojection_grid()
            if not ok_grid:
                return False
            self.fixed_output_wcs = self.reference_wcs_object
            self.fixed_output_shape = self.reference_shape
            if self.drizzle_active_session:
                self.drizzle_output_wcs = self.reference_wcs_object
                self.drizzle_output_shape_hw = self.reference_shape
        elif (
            self.freeze_reference_wcs
            and (
                self.drizzle_active_session
                or self.reproject_between_batches
                or self.reproject_coadd_final
            )
        ):
            ok_grid = self._prepare_global_reprojection_grid()
            if not ok_grid:
                return False
            self.fixed_output_wcs = self.reference_wcs_object
            self.fixed_output_shape = self.reference_shape
            if self.drizzle_active_session:
                self.drizzle_output_wcs = self.reference_wcs_object
                self.drizzle_output_shape_hw = self.reference_shape

        self.aligner.reference_image_path = reference_path_ui or None

        logger.debug(
            "DEBUG QM (start_processing V_StartProcessing_SaveDtypeOption_1): D√©marrage du thread worker..."
        )  # Version Log
        self.processing_thread = threading.Thread(
            target=self._worker, name="StackerWorker"
        )
        self.processing_thread.daemon = True
        self.processing_thread.start()
        self.processing_active = True

        self.update_progress("üöÄ Thread de traitement d√©marr√©.")
        logger.debug(
            "DEBUG QM (start_processing V_StartProcessing_SaveDtypeOption_1): Fin."
        )  # Version Log
        return True

    ###############################################################################################################################################

    def _save_drizzle_input_temp(self, aligned_data, header, tf=None):
        """
        Sauvegarde une image align√©e (HxWx3 float32) dans le dossier temp Drizzle,
        en transposant en CxHxW et en INJECTANT l'OBJET WCS DE R√âF√âRENCE stock√©
        dans le header sauvegard√©.

        Args:
            aligned_data (np.ndarray): Donn√©es align√©es (HxWx3 float32, 0-1).
            header (fits.Header): Header FITS ORIGINAL (pour m√©tadonn√©es non-WCS).
            tf (array-like, optional): Matrice de transformation affine 2x3
                appliqu√©e par ``cv2.warpAffine``.

        Returns:
            str or None: Chemin complet du fichier sauvegard√©, ou None en cas d'erreur.
        """
        # V√©rifications initiales
        if self.drizzle_temp_dir is None:
            self.update_progress("‚ùå Erreur interne: Dossier temp Drizzle non d√©fini.")
            return None
        os.makedirs(self.drizzle_temp_dir, exist_ok=True)
        if aligned_data.ndim != 3 or aligned_data.shape[2] != 3:
            self.update_progress(
                f"‚ùå Erreur interne: _save_drizzle_input_temp attend HxWx3, re√ßu {aligned_data.shape}"
            )
            return None
        # --- V√âRIFIER SI L'OBJET WCS DE R√âF√âRENCE EST DISPONIBLE ---
        if self.reference_wcs_object is None:
            self.update_progress(
                "‚ùå Erreur interne: Objet WCS de r√©f√©rence non disponible pour sauvegarde temp."
            )
            return None
        # --- FIN V√âRIFICATION ---

        try:
            temp_filename = f"aligned_input_{self.aligned_files_count:05d}.fits"
            temp_filepath = os.path.join(self.drizzle_temp_dir, temp_filename)

            # --- Pr√©parer les donn√©es : Transposer HxWxC -> CxHxW ---
            data_to_save = np.moveaxis(aligned_data, -1, 0).astype(np.float32)

            # --- Pr√©parer le header ---
            header_to_save = header.copy() if header else fits.Header()

            # --- EFFACER l'ancien WCS potentiellement invalide ---
            keys_to_remove = [
                "PC1_1",
                "PC1_2",
                "PC2_1",
                "PC2_2",
                "CD1_1",
                "CD1_2",
                "CD2_1",
                "CD2_2",
