

if not _FEATHERING_AVAILABLE:
    def feather_by_weight_map(img, wht, blur_px=256, eps=1e-6):
        logger.error("Fonction feather_by_weight_map non disponible (échec import).")
        return img  # Retourner l'image originale


def renormalize_fits(
    fits_path: str,
    method: Literal["none", "max", "n_images"],
    n_images: int,
) -> None:
    """In-place renormalises a drizzle FITS stack."""
    log = logging.getLogger(__name__)
    m = (method or "none").lower()
    if m not in {"none", "max", "n_images"}:
        log.debug(f"renormalize_fits: unknown method '{method}', fallback to 'none'")
        m = "none"
    if m == "none":
        return
    try:
        with fits.open(fits_path, mode="update", memmap=False) as hdul:
            orig_dtype = hdul[0].data.dtype
            data = hdul[0].data.astype(np.float32)
            hdr = hdul[0].header
            wht = None
            wht_orig_dtype = None
            if (
                len(hdul) > 1
                and hdul[1].header.get("EXTNAME", "").strip().upper() == "WHT"
            ):
                wht_orig_dtype = hdul[1].data.dtype
                wht = hdul[1].data.astype(np.float32)
            if wht is not None:
                wht_max = float(np.max(wht)) if wht.size else 1.0
                wht_mean = float(np.mean(wht)) if wht.size else 1.0
            else:
                wht_max = float(hdr.get("DRZWHT_MAX", 1.0))
                wht_mean = float(hdr.get("DRZWHT_MEAN", 1.0))
            if m == "max":
                s = 1.0 / max(wht_max, 1.0)
            else:  # "n_images"
                denom = max(wht_mean, 1e-9)
                s = float(n_images) / denom
            data *= s
            if wht is not None:
                wht *= s
            if np.issubdtype(orig_dtype, np.integer):
                hdul[0].data = np.round(data).astype(orig_dtype)
            else:
                hdul[0].data = data.astype(orig_dtype)
            if wht is not None:
                if np.issubdtype(wht_orig_dtype, np.integer):
                    hdul[1].data = np.round(wht).astype(wht_orig_dtype)
                else:
                    hdul[1].data = wht.astype(wht_orig_dtype)
            hdr["RENORM"] = (s, "Flux renormalisation factor")
            hdr["RENORMMD"] = (m, "Renormalisation method")
            hdul.flush()
        log.debug(
            f"renormalize_fits: method={m} factor={s:.4g} applied to {os.path.basename(fits_path)}"
        )
    except Exception:
        log.exception("renormalize_fits failed")
        raise


try:
    from ..enhancement.stack_enhancement import apply_low_wht_mask  # NOUVEL IMPORT

    _LOW_WHT_MASK_AVAILABLE = True
    logger.debug("Import apply_low_wht_mask depuis stack_enhancement OK.")
except ImportError as e_low_wht:
    _LOW_WHT_MASK_AVAILABLE = False
    logger.error(
        "Échec import apply_low_wht_mask: %s",
        e_low_wht,
    )

    def apply_low_wht_mask(
        img, wht, percentile=5, soften_px=128, progress_callback=None
    ):  # Factice
        if progress_callback:
            progress_callback(
                "   [LowWHTMask] ERREUR: Fonction apply_low_wht_mask non disponible (échec import).",
                None,
            )
        else:
            logger.error("Fonction apply_low_wht_mask non disponible (échec import).")
        return img


# --- Optional Third-Party Imports (Post-processing related) ---
# Ces imports sont tentés globalement. Des flags indiquent leur disponibilité.
_PHOTOUTILS_BG_SUB_AVAILABLE = False
try:
    from ..core.background import subtract_background_2d

    _PHOTOUTILS_BG_SUB_AVAILABLE = True
    logger.debug("Import subtract_background_2d (Photutils) OK.")
except ImportError as e:
    subtract_background_2d = None  # Fonction factice
    logger.warning("Échec import subtract_background_2d (Photutils): %s", e)

_BN_AVAILABLE = False  # Neutralisation de fond globale
try:
    from ..tools.stretch import neutralize_background_automatic

    _BN_AVAILABLE = True
    logger.debug("Import neutralize_background_automatic OK.")
except ImportError as e:
    neutralize_background_automatic = None  # Fonction factice
    logger.warning("Échec import neutralize_background_automatic: %s", e)

_SCNR_AVAILABLE = False  # SCNR Final
try:
    from ..enhancement.color_correction import apply_scnr

    _SCNR_AVAILABLE = True
    logger.debug("Import apply_scnr OK.")
except ImportError as e:
    apply_scnr = None  # Fonction factice
    logger.warning("Échec import apply_scnr: %s", e)

_CROP_AVAILABLE = False  # Rognage Final
try:
    from ..enhancement.stack_enhancement import apply_edge_crop

    _CROP_AVAILABLE = True
    logger.debug("Import apply_edge_crop OK.")
except ImportError as e:
    apply_edge_crop = None  # Fonction factice
    logger.warning("Échec import apply_edge_crop: %s", e)

# --- Imports INTERNES à déplacer en IMPORTS TARDIFS ---
# Ces modules seront importés seulement quand les méthodes spécifiques sont appelées
# pour éviter les dépendances circulaires au chargement initial.


from ..alignment.astrometry_solver import (  # Déplacé vers _worker/_process_file
    AstrometrySolver,
    solve_image_wcs,
)

# --- Configuration des Avertissements ---
warnings.filterwarnings("ignore", category=FITSFixedWarning)
logger.debug("Configuration warnings OK.")
# --- FIN Imports ---


class SeestarQueuedStacker:
    """
    Classe pour l'empilement des images Seestar avec file d'attente et traitement par lots.
    Gère l'alignement et l'empilement dans un thread séparé.
    Ajout de la pondération basée sur la qualité (SNR, Nombre d'étoiles).
    """

    logger.debug("Lecture de la définition de la classe SeestarQueuedStacker...")

    def __getstate__(self):
        """Return picklable state for multiprocessing."""
        state = self.__dict__.copy()
        for attr in (
            "progress_callback",
            "preview_callback",
            "queue",
            "gui_event_queue",
            "folders_lock",
            "processing_thread",
            "gui",
            "aligner",
            "local_aligner_instance",
            "astrometry_solver",
            "chroma_balancer",
            "autotuner",
            "drizzle_processes",
            "drizzle_executor",
        ):
            state[attr] = None

        # Remove any tkinter objects that may have been stored dynamically
        try:
            import tkinter
        except Exception:
            tkinter = None
        if tkinter is not None:
            for k, v in list(state.items()):
                if v is not None and type(v).__module__.startswith("tkinter"):
                    state[k] = None

        return state

    def __setstate__(self, state):
        self.__dict__.update(state)

    def _configure_global_threads(self, fraction: float) -> None:
        nthreads = max(1, math.floor(os.cpu_count() * fraction))
        for var in [
            "OMP_NUM_THREADS",
