                    logger.debug(
                        f"  DEBUG _worker (iter {iteration_count}): PRE-CALL _process_file pour '{file_name_for_log}'"
                    )
                    logger.debug(
                        f"    - use_local_aligner_for_this_mosaic_run: {use_local_aligner_for_this_mosaic_run}"
                    )
                    logger.debug(
                        f"    - use_astrometry_per_panel_mosaic: {use_astrometry_per_panel_mosaic}"
                    )
                    logger.debug(
                        f"    - self.is_mosaic_run (juste avant if/elif): {self.is_mosaic_run}"
                    )

                    _log_mem("before_align")
                    if use_local_aligner_for_this_mosaic_run:
                        logger.debug(
                            f"  DEBUG _worker (iter {iteration_count}): Entrée branche 'use_local_aligner_for_this_mosaic_run' pour _process_file."
                        )  # DEBUG
                        item_result_tuple = self._process_file(
                            file_path,
                            reference_image_data_for_global_alignment,
                            solve_astrometry_for_this_file=False,
                            fa_orb_features_config=self.fa_orb_features,
                            fa_min_abs_matches_config=self.fa_min_abs_matches,
                            fa_min_ransac_inliers_value_config=self.fa_min_ransac_raw,
                            fa_ransac_thresh_config=self.fa_ransac_thresh,
                            daofind_fwhm_config=self.fa_daofind_fwhm,
                            daofind_threshold_sigma_config=self.fa_daofind_thr_sig,
                            max_stars_to_describe_config=self.fa_max_stars_descr,
                            align_on_disk=self.align_on_disk,
                        )
                        _log_mem("after_align")

                        self.processed_files_count += (
                            1  # Mis ici car _process_file est appelé
                        )
                        if (
                            item_result_tuple
                            and isinstance(item_result_tuple, tuple)
                            and len(item_result_tuple) == 6
                            and item_result_tuple[0] is not None
                            and item_result_tuple[3] is not None
                            and isinstance(item_result_tuple[3], WCS)
                            and item_result_tuple[4] is not None
                        ):
                            (
                                panel_data,
                                panel_header,
                                _scores,
                                panel_wcs,
                                panel_matrix_m,
                                panel_mask,
                            ) = item_result_tuple
                            all_aligned_files_with_info_for_mosaic.append(
                                (
                                    panel_data,
                                    panel_header,
                                    panel_wcs,
                                    panel_matrix_m,
                                    panel_mask,
                                )
                            )
                            self.aligned_files_count += 1
                            self._increment_aligned_counter()
                            align_method_used_log = panel_header.get(
                                "_ALIGN_METHOD_LOG", ("Unknown", None)
                            )[0]
                            logger.debug(
                                f"  DEBUG QM [_worker / Mosaïque Locale]: Panneau '{file_name_for_log}' traité ({align_method_used_log}) et ajouté à all_aligned_files_with_info_for_mosaic."
                            )
                        else:
                            self.failed_align_count += 1
                            logger.debug(
                                f"  DEBUG QM [_worker / Mosaïque Locale]: Échec traitement/alignement panneau '{file_name_for_log}'. _process_file a retourné: {item_result_tuple}"
                            )
                            if hasattr(self, "_move_to_unaligned"):
                                self._move_to_unaligned(file_path)

                    elif use_astrometry_per_panel_mosaic:
                        logger.debug(
                            f"  DEBUG _worker (iter {iteration_count}): Entrée branche 'use_astrometry_per_panel_mosaic' pour _process_file."
                        )  # DEBUG
                        _log_mem("before_align")
                        item_result_tuple = self._process_file(
                            file_path,
                            reference_image_data_for_global_alignment,  # Passé mais pas utilisé pour l'alignement direct dans ce mode
                            solve_astrometry_for_this_file=(
                                False if self.reproject_between_batches else True
                            ),
                            align_on_disk=self.align_on_disk,
                        )
                        _log_mem("after_align")
                        self.processed_files_count += 1
                        if (
                            item_result_tuple
                            and isinstance(item_result_tuple, tuple)
                            and len(item_result_tuple) == 6
                            and item_result_tuple[0] is not None
                            and item_result_tuple[3] is not None
                            and isinstance(item_result_tuple[3], WCS)
                        ):
                            (
                                panel_data,
                                panel_header,
                                _scores,
                                wcs_object_panel,
                                M_returned,
                                valid_mask_panel,
                            ) = item_result_tuple
                            M_to_store = (
                                M_returned
                                if M_returned is not None
                                else np.array(
                                    [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0]], dtype=np.float32
                                )
                            )
                            all_aligned_files_with_info_for_mosaic.append(
                                (
                                    panel_data,
                                    panel_header,
                                    wcs_object_panel,
                                    M_to_store,
                                    valid_mask_panel,
                                )
                            )
                            self.aligned_files_count += 1
                            self._increment_aligned_counter()
                            align_method_used_log = panel_header.get(
                                "_ALIGN_METHOD_LOG", ("Unknown", None)
                            )[0]
                            logger.debug(
                                f"  DEBUG QM [_worker / Mosaïque AstroPanel]: Panneau '{file_name_for_log}' traité ({align_method_used_log}) et ajouté à all_aligned_files_with_info_for_mosaic."
                            )
                        else:
                            self.failed_align_count += 1
                            logger.debug(
                                f"  DEBUG QM [_worker / Mosaïque AstroPanel]: Échec traitement/alignement panneau '{file_name_for_log}'. _process_file a retourné: {item_result_tuple}"
                            )
                            if hasattr(self, "_move_to_unaligned"):
                                self._move_to_unaligned(file_path)

                    else:  # Stacking Classique ou Drizzle Standard (non-mosaïque)
                        logger.debug(
                            f"  DEBUG _worker (iter {iteration_count}): Entrée branche 'Stacking Classique/Drizzle Standard' pour _process_file."
                        )
                        solve_astrometry = False
                        if (
                            self.reproject_between_batches
                            and self.drizzle_active_session
                            and not current_batch_items_with_masks_for_stack_batch
                        ):
                            solve_astrometry = True

                        item_result_tuple = self._process_file(
                            file_path,
                            reference_image_data_for_global_alignment,
                            solve_astrometry_for_this_file=solve_astrometry,
                            align_on_disk=self.align_on_disk,
                        )
                        self.processed_files_count += 1
                        if (
                            item_result_tuple
                            and isinstance(item_result_tuple, tuple)
                            and len(item_result_tuple) == 6
                            and item_result_tuple[0] is not None
                        ):
                            if self.reproject_between_batches:
                                # --- NEW incremental reprojection on *stacked* batches ---
                                # store only the components expected by
                                # ``_stack_batch`` (data, header, scores,
                                # wcs_object, valid_mask)
                                # _stack_batch expects (data, header, scores, wcs, valid_mask)
                                # item_result_tuple structure is
                                # (data, header, scores, wcs, matrix_M, valid_mask)
                                current_batch_items_with_masks_for_stack_batch.append(
                                    (
                                        item_result_tuple[0],
                                        item_result_tuple[1],
                                        item_result_tuple[2],
                                        item_result_tuple[3],
                                        item_result_tuple[5],
                                    )
                                )
                                self._current_batch_paths.append(file_path)

                                if self.batch_size == 0:
                                    trigger = float("inf")
                                elif self.batch_size == 1 and getattr(
                                    self, "chunk_size", None
                                ):
                                    trigger = getattr(self, "chunk_size")
                                else:
                                    trigger = max(1, self.batch_size)
                                if (
                                    len(current_batch_items_with_masks_for_stack_batch)
                                    >= trigger
                                ):
                                    self.stacked_batches_count += 1
                                    num_in_batch = len(
                                        current_batch_items_with_masks_for_stack_batch
                                    )

                                    # 1. Stack the batch (classic SUM/W)
                                    stacked_np, hdr, wht_2d = self._stack_batch(
                                        current_batch_items_with_masks_for_stack_batch,
                                        self.stacked_batches_count,
                                        self.total_batches_estimated,
                                    )
                                    if stacked_np is None:
                                        current_batch_items_with_masks_for_stack_batch.clear()
                                        if getattr(self, "batch_size", 1) == 1:
                                            getattr(self, "_indices_cache", {}).clear()
                                        gc.collect()
                                    else:
                                        # 2. Ensure WCS on the stacked image
                                        (
                                            solved_path,
                                            _,
                                        ) = self._save_and_solve_classic_batch(
                                            stacked_np,
                                            wht_2d,
                                            hdr,
                                            self.stacked_batches_count,
                                        )
                                        batch_wcs = None
                                        try:
                                            batch_wcs = WCS(hdr, naxis=2)
                                            ensure_wcs_pixel_shape(
                                                batch_wcs,
                                                int(hdr.get("NAXIS2")),
                                                int(hdr.get("NAXIS1")),
                                            )
                                        except Exception:
                                            batch_wcs = None

                                        # 3. Accumulate if astrometric solve succeeded or not reprojecting
                                        if (
                                            not (
                                                self.reproject_between_batches
                                                or self.reproject_coadd_final
                                            )
                                            or self._last_classic_batch_solved
                                        ):
                                            self._combine_batch_result(
                                                stacked_np,
                                                hdr,
                                                wht_2d,
                                                batch_wcs=batch_wcs,
                                            )
                                        else:
                                            self.update_progress(
                                                "   -> Batch sans r\xe9solution ignor\xe9 pour le reproject",
                                                "WARN",
                                            )
                                        if hasattr(self.cumulative_sum_memmap, "flush"):
                                            self.cumulative_sum_memmap.flush()
                                        if hasattr(self.cumulative_wht_memmap, "flush"):
                                            self.cumulative_wht_memmap.flush()
                                        if not self.drizzle_active_session:
                                            self._update_preview_sum_w()

                                        # After accumulation, solve the cumulative stack
                                        if self.reproject_between_batches:
                                            (
                                                stack_img,
                                                solved_hdr,
                                            ) = self._solve_cumulative_stack()
                                            if (
                                                stack_img is not None
                                                and solved_hdr is not None
                                            ):
                                                reference_image_data_for_global_alignment = (
                                                    stack_img
                                                )
                                                reference_header_for_global_alignment = (
                                                    solved_hdr.copy()
                                                )
                                            else:
                                                reference_image_data_for_global_alignment = stacked_np.astype(
                                                    np.float32, copy=True
                                                )
                                                reference_header_for_global_alignment = (
                                                    hdr.copy()
                                                )
                                        else:
                                            reference_image_data_for_global_alignment = stacked_np.astype(
                                                np.float32, copy=True
                                            )
                                            reference_header_for_global_alignment = (
                                                hdr.copy()
                                            )

                                        current_batch_items_with_masks_for_stack_batch.clear()
                                        self._current_batch_paths = []
                                        self._save_partial_stack()
                                        if getattr(self, "batch_size", 1) == 1:
                                            getattr(self, "_indices_cache", {}).clear()
                                        gc.collect()

                            else:
