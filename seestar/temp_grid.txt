        )

        # ------------------ 2. Construction d'un WCS sans rotation ------------------
        out_wcs = WCS(naxis=2)
        out_wcs.wcs.crval = list(ref_wcs.wcs.crval)
        out_wcs.wcs.crpix = (
            np.asarray(ref_wcs.wcs.crpix, dtype=float) * scale_factor
        ).tolist()

        ref_scale_arcsec = self.reference_pixel_scale_arcsec
        if ref_scale_arcsec is None:
            try:
                ref_scale_deg = np.mean(np.abs(proj_plane_pixel_scales(ref_wcs)))
                ref_scale_arcsec = ref_scale_deg * 3600.0
            except Exception:
                ref_scale_arcsec = 1.0

        final_scale_deg = (ref_scale_arcsec / scale_factor) / 3600.0
        out_wcs.wcs.cd = np.array([[-final_scale_deg, 0.0], [0.0, final_scale_deg]])
        out_wcs.wcs.ctype = ["RA---TAN", "DEC--TAN"]
        out_wcs.pixel_shape = (out_w, out_h)
        try:
            out_wcs._naxis1 = out_w
            out_wcs._naxis2 = out_h
        except AttributeError:
            pass

        self.fixed_output_wcs = out_wcs
        self.fixed_output_shape = out_shape_hw
        logger.debug(f"[DrizzleWCS] Output WCS OK  (shape={out_shape_hw})")
        return out_wcs, out_shape_hw

    def _calculate_fixed_orientation_grid(self, ref_wcs, scale_factor: float = 1.0):
        """Return a WCS derived from ``ref_wcs`` with no rotation."""
        if not ref_wcs or not ref_wcs.is_celestial or ref_wcs.pixel_shape is None:
            return None, None
        try:
            ref_h = int(ref_wcs.pixel_shape[1])
            ref_w = int(ref_wcs.pixel_shape[0])
        except Exception:
            return None, None

        out_h = max(1, int(round(ref_h * scale_factor)))
        out_w = max(1, int(round(ref_w * scale_factor)))
        out_shape_hw = (out_h, out_w)

        out_wcs = WCS(naxis=2)
        out_wcs.wcs.crval = list(ref_wcs.wcs.crval)
        out_wcs.wcs.crpix = (
            np.asarray(ref_wcs.wcs.crpix, dtype=float) * scale_factor
        ).tolist()

        ref_scale_arcsec = self.reference_pixel_scale_arcsec
        if ref_scale_arcsec is None:
            try:
                ref_scale_deg = np.mean(np.abs(proj_plane_pixel_scales(ref_wcs)))
                ref_scale_arcsec = ref_scale_deg * 3600.0
            except Exception:
                ref_scale_arcsec = 1.0

        final_scale_deg = (ref_scale_arcsec / scale_factor) / 3600.0
        out_wcs.wcs.cd = np.array([[-final_scale_deg, 0.0], [0.0, final_scale_deg]])
        out_wcs.wcs.ctype = ["RA---TAN", "DEC--TAN"]
        out_wcs.pixel_shape = (out_w, out_h)
        try:
            out_wcs._naxis1 = out_w
            out_wcs._naxis2 = out_h
        except AttributeError:
            pass

        return out_wcs, out_shape_hw

    ###########################################################################################################################################################

    def _calculate_final_mosaic_grid_dynamic(
        self, all_input_wcs_list, all_input_headers_list=None, scale_factor: float = 1.0
    ):
        """Compute a global WCS using a dynamic bounding box with optional rotation.

        Parameters
        ----------
        all_input_wcs_list : list
            List of input :class:`~astropy.wcs.WCS` objects.
        all_input_headers_list : list, optional
            Optional list of FITS headers matching ``all_input_wcs_list`` used to
            recover missing ``pixel_shape`` information.
        scale_factor : float, optional
            Drizzle scale factor to apply to the output grid. The final pixel
            scale of the mosaic is divided by this factor. Defaults to ``1.0``.
        """
        num_wcs = len(all_input_wcs_list)
        logger.debug(
            f"DEBUG (Backend _calculate_final_mosaic_grid - Dynamic Box): Appel avec {num_wcs} WCS (scale={scale_factor})."
        )
        self.update_progress(
            f"üìê Calcul de la grille de sortie dynamique ({num_wcs} WCS)..."
        )
        if num_wcs == 0:
            return None, None

        all_sky_corners_list = []
        for i, wcs_in in enumerate(all_input_wcs_list):
            if wcs_in is None or not wcs_in.is_celestial:
                continue
            if (
                wcs_in.pixel_shape is None
                and all_input_headers_list
                and i < len(all_input_headers_list)
            ):
                hdr = all_input_headers_list[i]
                n1 = hdr.get("NAXIS1")
                n2 = hdr.get("NAXIS2")
                if n1 and n2:
                    wcs_in.pixel_shape = (int(n1), int(n2))
            if wcs_in.pixel_shape is None:
                continue
            nx, ny = wcs_in.pixel_shape
            pixel_corners = np.array(
                [[0, 0], [nx - 1, 0], [nx - 1, ny - 1], [0, ny - 1]], dtype=np.float64
            )
            sky_corners = wcs_in.pixel_to_world(
                pixel_corners[:, 0], pixel_corners[:, 1]
            )
            all_sky_corners_list.append(sky_corners)

        if not all_sky_corners_list:
            return None, None

        all_corners_flat_skycoord = skycoord_concatenate(all_sky_corners_list)

        center_ra = np.median([w.wcs.crval[0] for w in all_input_wcs_list])
        center_dec = np.median([w.wcs.crval[1] for w in all_input_wcs_list])

        local_tan = WCS(naxis=2)
        local_tan.wcs.ctype = ["RA---TAN", "DEC--TAN"]
        local_tan.wcs.crval = [center_ra, center_dec]
        local_tan.wcs.crpix = [0.0, 0.0]
        local_tan.wcs.cd = np.eye(2)

        xy = np.vstack(local_tan.world_to_pixel(all_corners_flat_skycoord)).T
        eigvals, eigvecs = np.linalg.eig(np.cov(xy, rowvar=False))
        theta = np.arctan2(eigvecs[1, 0], eigvecs[0, 0]) * 180 / np.pi

        rot = np.array(
            [
                [np.cos(np.deg2rad(-theta)), -np.sin(np.deg2rad(-theta))],
                [np.sin(np.deg2rad(-theta)), np.cos(np.deg2rad(-theta))],
            ]
        )
        xy_rot = xy @ rot.T
        minx, miny = xy_rot.min(axis=0)
        maxx, maxy = xy_rot.max(axis=0)

        scales_arcsec = []
        for w in all_input_wcs_list:
            try:
                scales_arcsec.append(
                    np.mean(np.abs(proj_plane_pixel_scales(w))) * 3600.0
                )
            except Exception:
                pass
        final_pixel_scale_arcsec = (
            float(np.median(scales_arcsec)) if scales_arcsec else 1.0
        )
        final_pixel_scale_deg = final_pixel_scale_arcsec / 3600.0
        # Apply drizzle scale factor if requested
        if scale_factor and scale_factor != 1.0:
            final_pixel_scale_deg /= float(scale_factor)

        content_width_deg = maxx - minx
        content_height_deg = maxy - miny

        nw = int(np.ceil(content_width_deg / final_pixel_scale_deg)) + 4
        nh = int(np.ceil(content_height_deg / final_pixel_scale_deg)) + 4

        output_wcs = WCS(naxis=2)
        output_wcs.wcs.ctype = ["RA---TAN", "DEC--TAN"]
        output_wcs.wcs.crval = [center_ra, center_dec]
        # Center the mosaic so that the lower-left corner of the bounding box
        # maps to pixel (1, 1). The PCA-derived ``minx``/``miny`` values are in
        # degrees, so convert them into pixel units using the final pixel scale
        # before assigning them to ``CRPIX``. This ensures that a single-frame
        # reprojection aligns correctly on the output canvas instead of being
        # offset to a corner.
        output_wcs.wcs.crpix = [
            (-minx / final_pixel_scale_deg) + 1.0,
            (-miny / final_pixel_scale_deg) + 1.0,
        ]
        cos_t = np.cos(np.deg2rad(theta))
        sin_t = np.sin(np.deg2rad(theta))
        output_wcs.wcs.cd = final_pixel_scale_deg * np.array(
            [[-cos_t, sin_t], [sin_t, cos_t]]
        )
        output_wcs.pixel_shape = (nw, nh)

        self.update_progress(
            f"üó∫Ô∏è Global grid : dynamic box {(nh, nw)} px, theta={theta:.2f}¬∞",
            "INFO",
        )
        logger.debug(
            f"DEBUG (Backend Grid Calc): dynamic grid {nw}x{nh}  scale={final_pixel_scale_arcsec:.3f} arcsec/pix  theta={theta:.2f}  factor={scale_factor}"
        )
        return output_wcs, (nh, nw)

    def _calculate_final_mosaic_grid(
        self,
        all_input_wcs_list,
        all_input_headers_list=None,
        scale_factor: float = 1.0,
        auto_rotate: bool = False,
    ):
        """Compute the final mosaic grid using ``find_optimal_celestial_wcs``.

        Parameters
        ----------
        all_input_wcs_list : list
            List of input :class:`~astropy.wcs.WCS` objects.
        all_input_headers_list : list, optional
            Optional list of FITS headers matching ``all_input_wcs_list`` used to
            recover missing ``pixel_shape`` information.
        scale_factor : float, optional
            Drizzle scale factor to apply to the output grid. The final pixel
            scale of the mosaic is divided by this factor. Defaults to ``1.0``.
        auto_rotate : bool, optional
            If ``True`` the output grid is allowed to rotate to minimize the
            final canvas size similar to ZeMosaic's behaviour.
        """

        if self.freeze_reference_wcs and self.reference_wcs_object is not None:
            return self.reference_wcs_object, (
                int(self.reference_header_for_wcs["NAXIS2"]),
                int(self.reference_header_for_wcs["NAXIS1"]),
            )

        num_wcs = len(all_input_wcs_list)
        logger.debug(
            f"DEBUG (Backend _calculate_final_mosaic_grid - Optimal): Appel avec {num_wcs} WCS (scale={scale_factor})."
        )
        self.update_progress(f"üìê Calcul de la grille de sortie ({num_wcs} WCS)...")

        if num_wcs == 0:
            return None, None

        try:
            from reproject.mosaicking import find_optimal_celestial_wcs
        except Exception as e:
            logger.error("find_optimal_celestial_wcs unavailable: %s", e)
            find_optimal_celestial_wcs = None

        from ..core.reprojection_utils import compute_final_output_grid

        def _fallback_grid(wcs_list, shapes_hw_list, scale_factor, auto_rotate=False):
            header_infos = list(zip(shapes_hw_list, wcs_list))
