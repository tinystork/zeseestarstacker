                        self._save_final_stack(
                            output_filename_suffix="_classic_reproject"
                        )
                    else:
                        self.update_progress(
                            "   Aucune image accumul√©e pour sauvegarde."
                        )
                        self.final_stacked_path = None
                elif self.reproject_coadd_final:
                    self.update_progress("üèÅ Finalisation Reproject&Coadd...")

                    solved_batches = [
                        bf
                        for bf in self.intermediate_classic_batch_files
                        if bf[0]
                        not in getattr(self, "unsolved_classic_batch_files", set())
                    ]
                    if solved_batches:
                        if len(solved_batches) == 1:
                            self._finalize_single_classic_batch(solved_batches[0])
                        elif not self._reproject_classic_batches_zm(solved_batches):
                            if self._reproject_classic_batches(solved_batches):
                                self._save_final_stack(
                                    "_classic_reproject",
                                    drizzle_final_sci_data=self.current_stack,
                                    drizzle_final_wht_data=self.current_coverage,
                                    preserve_linear_output=True,
                                )
                            else:
                                self.update_progress(
                                    "   Reprojection finale √©chou√©e.", "WARN"
                                )
                                self.final_stacked_path = None

                    else:
                        self.update_progress(
                            "   Aucune batch sauvegard√© pour reproject&coadd.",
                        )
                        self.final_stacked_path = None
                else:
                    self.update_progress(
                        "üèÅ Finalisation Stacking Classique (SUM/W)..."
                    )
                    if self.images_in_cumulative_stack > 0 or (
                        hasattr(self, "cumulative_sum_memmap")
                        and self.cumulative_sum_memmap is not None
                    ):
                        self._save_final_stack(output_filename_suffix="_classic_sumw")
                    else:
                        self.update_progress(
                            "   Aucune image accumul√©e dans le stack classique. Sauvegarde ignor√©e."
                        )
                        self.final_stacked_path = None
            else:  # Cas impr√©vu
                logger.debug(
                    "DEBUG QM [_worker V_DrizIncrTrue_Fix1]: *** ENTR√âE DANS LE 'else' FINAL (√âTAT NON G√âR√â) ***"
                )
                self.update_progress(
                    "‚ö†Ô∏è √âtat de finalisation non g√©r√©. Aucune action de sauvegarde principale."
                )
                self.processing_error = "√âtat de finalisation non g√©r√©."
                self.final_stacked_path = None

            logger.debug(
                "DEBUG QM [_worker V_DrizIncrTrue_Fix1]: *** APR√àS LE BLOC if/elif/else DE FINALISATION ***"
            )
            if (not ibn_finalized) and getattr(self, "interbatch_norm_active", False):
                self._interbatch_finalize_session()
                ibn_finalized = True

        # --- FIN DU BLOC TRY PRINCIPAL DU WORKER ---
        except RuntimeError as rte:
            self.update_progress(
                f"‚ùå ERREUR CRITIQUE (RuntimeError) dans le worker: {rte}", "ERROR"
            )  # S'assurer que "ERROR" est pass√© pour le log GUI
            logger.debug(f"ERREUR QM [_worker V_NoDerotation]: RuntimeError: {rte}")
            traceback.print_exc(limit=3)
            self.processing_error = f"RuntimeError: {rte}"
            self.stop_processing = True  # Provoquer l'arr√™t propre du thread
        except Exception as e_global_worker:
            self.update_progress(
                f"‚ùå ERREUR INATTENDUE GLOBALE dans le worker: {e_global_worker}",
                "ERROR",
            )
            logger.debug(
                f"ERREUR QM [_worker V_NoDerotation]: Exception Globale: {e_global_worker}"
            )
            traceback.print_exc(limit=3)
            self.processing_error = f"Erreur Globale: {e_global_worker}"
            self.stop_processing = True  # Provoquer l'arr√™t propre du thread
        finally:
            logger.debug(
                f"DEBUG QM [_worker V_NoDerotation]: Entree dans le bloc FINALLY principal du worker."
            )
            if (not ibn_finalized) and getattr(self, "interbatch_norm_active", False):
                self._interbatch_finalize_session()
            if (
                hasattr(self, "cumulative_sum_memmap")
                and self.cumulative_sum_memmap is not None
                or hasattr(self, "cumulative_wht_memmap")
                and self.cumulative_wht_memmap is not None
            ):
                self._close_memmaps()

            if self.perform_cleanup:
                self.update_progress("üßπ Nettoyage final des fichiers temporaires...")
                self._cleanup_drizzle_temp_files()  # Dossier des inputs Drizzle (aligned_input_*.fits)
                self._cleanup_aligned_temp_files()  # Fichiers align√©s batch=1
                self._cleanup_drizzle_batch_outputs()  # Dossier des sorties Drizzle par lot (batch_*_sci.fits, batch_*_wht_*.fits)
                self._cleanup_classic_batch_outputs()  # Dossier des sorties Classic par lot
                self._cleanup_mosaic_panel_stacks_temp()  # Dossier des stacks de panneaux (si ancienne logique ou tests)
                if not self.user_requested_stop:
                    self.cleanup_temp_reference()  # Fichiers reference_image.fit/png
                if not self.stop_processing:
                    self._cleanup_memmap_files()

            self.processing_active = False
            self.stop_processing_flag_for_gui = (
                self.stop_processing
            )  # Transmettre l'√©tat d'arr√™t √† l'UI
            if self.autotuner:
                self.autotuner.stop()
            self.__class__.stop_processing(self)
            gc.collect()
            logger.debug(
                f"DEBUG QM [_worker V_NoDerotation]: Fin du bloc FINALLY principal. Flag processing_active mis √† False."
            )
            self.update_progress("üö™ Thread de traitement principal termin√©.")

    ############################################################################################################################

    # --- DANS LA CLASSE SeestarQueuedStacker DANS seestar/queuep/queue_manager.py ---

    def _generate_and_save_mosaic_alignment_log(
        self,
        all_aligned_panel_info_list: list,
        anchor_wcs_details: dict,
        final_output_grid_details: dict,
    ):
        """
        G√©n√®re un log d√©taill√© sur l'alignement de la mosa√Øque et le sauvegarde.
        MODIFIED V2: Gestion plus robuste de la lecture de _ALIGN_METHOD_LOG depuis le header.
        """
        if not self.output_folder:
            logger.debug(
                "WARN QM [_generate_mosaic_log V2]: Output folder non d√©fini, log non sauvegard√©."
            )
            return

        log_lines = []
        separator = "=" * 70

        log_lines.append(
            f"{separator}\nRAPPORT D'ALIGNEMENT DE MOSA√èQUE (V2)\n{separator}"
        )
        log_lines.append(f"Date du rapport: {time.strftime('%Y-%m-%d %H:%M:%S')}")
        log_lines.append(f"Dossier de sortie: {self.output_folder}")

        # --- 1. Param√®tres Cl√©s de la Mosa√Øque ---
        log_lines.append(f"\n--- Param√®tres de la Mosa√Øque Utilis√©s ---")
        log_lines.append(
            f"  Mode d'alignement: {getattr(self, 'mosaic_alignment_mode', 'N/A')}"
        )
        log_lines.append(
            f"  Fallback WCS activ√©: {getattr(self, 'use_wcs_fallback_for_mosaic', 'N/A')}"
        )
        log_lines.append(
            f"  FastAligner - Seuil RANSAC: {getattr(self, 'fa_ransac_thresh', 'N/A')}"
        )
        log_lines.append(
            f"  FastAligner - Min Abs Matches: {getattr(self, 'fa_min_abs_matches', 'N/A')}"
        )
        log_lines.append(
            f"  FastAligner - Min RANSAC Raw (valeur config): {getattr(self, 'fa_min_ransac_raw', 'N/A')}"
        )
        log_lines.append(
            f"  FastAligner - ORB Features (cible): {getattr(self, 'fa_orb_features', 'N/A')}"
        )
        log_lines.append(
            f"  FastAligner DAO - FWHM: {getattr(self, 'fa_daofind_fwhm', 'N/A')}"
        )
        log_lines.append(
            f"  FastAligner DAO - Seuil Sigma Factor: {getattr(self, 'fa_daofind_thr_sig', 'N/A')}"
        )
        log_lines.append(
            f"  FastAligner DAO - Max √âtoiles Desc.: {getattr(self, 'fa_max_stars_descr', 'N/A')}"
        )
        log_lines.append(
            f"  Drizzle Mosa√Øque - Kernel: {getattr(self, 'mosaic_drizzle_kernel', 'N/A')}"
        )
        log_lines.append(
            f"  Drizzle Mosa√Øque - Pixfrac: {getattr(self, 'mosaic_drizzle_pixfrac', 'N/A')}"
        )
        log_lines.append(
            f"  Drizzle Mosa√Øque - WHT Threshold: {getattr(self, 'mosaic_drizzle_wht_threshold', 'N/A')}"
        )
        log_lines.append(
            f"  Drizzle Mosa√Øque - √âchelle Globale Appliqu√©e: {getattr(self, 'drizzle_scale', 'N/A')}x"
        )

        # --- 2. Informations sur le WCS du Panneau d'Ancrage ---
        log_lines.append(f"\n--- WCS du Panneau d'Ancrage ---")
        if anchor_wcs_details:
            log_lines.append(
                f"  Fichier Source Ancre: {anchor_wcs_details.get('source_file', 'N/A')}"
            )
            log_lines.append(f"  Type de WCS: {anchor_wcs_details.get('type', 'N/A')}")
            log_lines.append(
                f"  CRVAL (RA, Dec): {anchor_wcs_details.get('crval', 'N/A')}"
            )
            log_lines.append(
                f"  CRPIX (X, Y): {anchor_wcs_details.get('crpix', 'N/A')}"
            )
            log_lines.append(
                f"  √âchelle (arcsec/pix): {anchor_wcs_details.get('scale_arcsec_pix', 'N/A')}"
            )
            log_lines.append(
                f"  Shape Pixel WCS (W,H): {anchor_wcs_details.get('pixel_shape_wh', 'N/A')}"
            )
            log_lines.append(
                f"  Distorsion SIP pr√©sente: {anchor_wcs_details.get('sip', 'N/A')}"
            )
            log_lines.append(
                f"  Info Solveur AN_SOLVED: {anchor_wcs_details.get('AN_SOLVED', 'N/A')}"
            )
            log_lines.append(
                f"  Info Solveur AN_FIELD_SCALE_ASEC: {anchor_wcs_details.get('AN_FIELD_SCALE_ASEC', 'N/A')}"
            )
        else:
            log_lines.append("  Informations sur le WCS de l'ancre non disponibles.")

        # --- 3. R√©sum√© de l'Alignement pour Chaque Panneau ---
        log_lines.append(
            f"\n--- D√©tails de l'Alignement des Panneaux (par rapport √† l'ancre) ---"
        )
        num_panneaux_pour_alignement_relatif = 0  # Panneaux autres que l'ancre
        num_fastalign_succes = 0
        num_fallback_wcs_tentatives = 0  # Combien de fois le fallback a √©t√© tent√©
        num_fallback_wcs_succes = 0
        num_align_echecs_complets = 0

        if not all_aligned_panel_info_list:
            log_lines.append(
                "  Aucun panneau (m√™me pas l'ancre) n'a √©t√© collect√© pour la mosa√Øque."
            )
        else:
            for idx, panel_info in enumerate(all_aligned_panel_info_list):
                if not isinstance(panel_info, tuple) or len(panel_info) < 4:
                    log_lines.append(
                        f"  Panneau {idx}: Format d'information invalide. Ignor√©."
                    )
                    continue

                # panel_info = (image_data_orig, header, wcs_ANCRE_POUR_M, matrix_M, valid_mask)
                panel_header = panel_info[1]
                panel_filename_tuple = panel_header.get(
                    "_SRCFILE", (f"Panneau_{idx}_NomInconnu", "")
                )
                panel_filename = (
                    panel_filename_tuple[0]
                    if isinstance(panel_filename_tuple, tuple)
                    else str(panel_filename_tuple)
                )

                matrix_m = panel_info[3]

                log_lines.append(
                    f"  Panneau {idx+1}/{len(all_aligned_panel_info_list)}: {panel_filename}"
                )  # Afficher 1-based

                if idx == 0 and panel_filename == anchor_wcs_details.get(
                    "source_file", ""
                ):  # Identification plus robuste de l'ancre
                    log_lines.append(f"    -> R√¥le: Ancre de la mosa√Øque.")
                    log_lines.append(
                        f"    -> Matrice M (normalement identit√© pour ancre): \n{matrix_m}"
                    )
                else:  # Panneaux non-ancre
                    num_panneaux_pour_alignement_relatif += 1
                    # Lire la m√©thode d'alignement depuis le header du panneau
                    align_method_from_header_raw = panel_header.get(
                        "_ALIGN_METHOD_LOG", "Non_Loggu√©"
                    )
                    align_method_from_header = (
                        align_method_from_header_raw[0]
                        if isinstance(align_method_from_header_raw, tuple)
                        else str(align_method_from_header_raw)
                    )

                    log_lines.append(
                        f"    -> M√©thode d'alignement (loggu√©e): {align_method_from_header}"
                    )
                    log_lines.append(
                        f"    -> Matrice M calcul√©e vers l'ancre: \n{matrix_m}"
                    )

                    if align_method_from_header == "FastAligner_Success":
                        num_fastalign_succes += 1
                    elif align_method_from_header == "WCS_Fallback_Success":
                        num_fallback_wcs_succes += 1
