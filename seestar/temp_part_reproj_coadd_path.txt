            if self.reference_header_for_wcs is not None:
                if (
                    input_wcs is not None
                    and self.reference_wcs_object is not None
                    and self.reference_shape is not None
                ):
                    try:
                        final_stacked = reproject_to_reference_wcs(
                            final_stacked,
                            input_wcs,
                            self.reference_wcs_object,
                            self.reference_shape,
                        )
                        final_wht = reproject_to_reference_wcs(
                            final_wht,
                            input_wcs,
                            self.reference_wcs_object,
                            self.reference_shape,
                        )
                    except Exception:
                        pass
                header.update(
                    {
                        k: self.reference_header_for_wcs[k]
                        for k in [
                            "CRPIX1",
                            "CRPIX2",
                            "CDELT1",
                            "CDELT2",
                            "CD1_1",
                            "CD1_2",
                            "CD2_1",
                            "CD2_2",
                            "CTYPE1",
                            "CTYPE2",
                            "CRVAL1",
                            "CRVAL2",
                        ]
                        if k in self.reference_header_for_wcs
                    }
                )
                header["NAXIS1"] = final_stacked.shape[1]
                header["NAXIS2"] = final_stacked.shape[0]
                data_cxhxw = np.moveaxis(final_stacked, -1, 0)
                fits.PrimaryHDU(data=data_cxhxw, header=header).writeto(
                    sci_fits, overwrite=True, output_verify="ignore"
                )
                for i, wht_path in enumerate(wht_paths):
                    fits.PrimaryHDU(data=final_wht.astype(np.float32)).writeto(
                        wht_path, overwrite=True, output_verify="ignore"
                    )

        self._last_classic_batch_solved = solved_ok

        if self.reproject_coadd_final:
            # Simply store the batch for the final reproject+coadd pass
            self.intermediate_classic_batch_files.append((sci_fits, wht_paths))
        elif not solved_ok:
            self.unsolved_classic_batch_files.add(sci_fits)

        return sci_fits, wht_paths

    def _reproject_classic_batches(self, batch_files: tBatchFiles) -> bool:
        """Reproject saved *classic* batches to a common grid and merge them.

        This variant first aligns **every batch** onto ``self.reference_wcs_object``
        (when provided), ensuring that the subsequent call to
        :pyfunc:`reproject_and_coadd` only has to *combine* images that are already
        pixel‑perfectly registered.  This reproduces the behaviour of the simple
        « Reproject » mode and prevents the blur previously observed in
        « Reproject + Co‑add ».
        """

        self._ensure_reference_wcs_for_mode0(batch_files)

        try:
            from seestar.enhancement.reproject_utils import (
                reproject_and_coadd,
                reproject_interp,
                subtract_sigma_clipped_median,
            )
        except Exception as e:
            self.update_progress(
                f"⚠️ Outils de reprojection indisponibles: {e}", "WARN"
            )
            return False

        mode = str(getattr(self, "stack_final_combine", "")).lower()
        bs_current = getattr(self, "batch_size", 0)
        default_match_bg = (mode == "reproject_coadd") or (bs_current != 1)
        match_bg = self._get_final_match_background(default=default_match_bg)
        if match_bg and mode == "reproject_coadd":
            logger.info(
                "[MATCH_BG] Background matching enabled for final coadd (mode=%s)",
                getattr(self, "stack_final_combine", mode),
            )

        # --- 1. Containers -------------------------------------------------------
        channel_arrays_wcs = [[] for _ in range(3)]  # per‑channel data + WCS pairs
        channel_footprints = [[] for _ in range(3)]  # per‑channel weight maps
        wcs_for_grid: List[WCS] = []
        headers_for_grid = []
        ref_p1 = None
        ref_p99 = None

        # --- 2. Loop over saved batch FITS --------------------------------------
        for sci_path, wht_paths in batch_files:
            if sci_path in getattr(self, "unsolved_classic_batch_files", set()):
                self.update_progress(
                    f"   -> Batch ignoré (non résolu) {sci_path}",
                    "WARN",
                )
                continue

            hdr = None
            # Ensure a valid WCS is present when using reproject+coadd. Older
            # ``batch_size=0`` runs already stored the reference WCS in the batch
            # header, so avoid re-solving when these keywords are present.
            if getattr(self, "reproject_coadd_final", False):
                if (
                    getattr(self, "batch_size", 0) == 0
                    and getattr(self, "reference_header_for_wcs", None) is not None
                ):
                    # In ``batch_size=0`` mode always force the reference WCS so
                    # that aligned batches share identical astrometric metadata.
                    hdr = self.reference_header_for_wcs.copy()
                    has_wcs = True
                else:
                    try:
                        hdr = fits.getheader(sci_path, memmap=False)
                        has_wcs = all(
                            k in hdr
                            for k in (
                                "CRVAL1",
                                "CRVAL2",
                                "CD1_1",
                                "CD1_2",
                                "CD2_1",
                                "CD2_2",
                            )
                        )
                    except Exception:
                        hdr = None
                        has_wcs = False
                    if not has_wcs:
                        if getattr(self, "reference_header_for_wcs", None) is not None:
                            # Inject the reference WCS to mirror previous batch_size=0 behaviour
                            try:
                                hdr = hdr or fits.Header()
                                for k in (
                                    "CRPIX1",
                                    "CRPIX2",
                                    "CDELT1",
                                    "CDELT2",
                                    "CD1_1",
                                    "CD1_2",
                                    "CD2_1",
                                    "CD2_2",
                                    "CTYPE1",
                                    "CTYPE2",
                                    "CRVAL1",
                                    "CRVAL2",
                                ):
                                    if k in self.reference_header_for_wcs:
                                        hdr[k] = self.reference_header_for_wcs[k]
                                data = fits.getdata(sci_path, memmap=False)
                                fits.PrimaryHDU(data=data, header=hdr).writeto(
                                    sci_path, overwrite=True, output_verify="ignore"
                                )
                                has_wcs = True
