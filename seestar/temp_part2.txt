    _stack_winsorized_sigma,
)
from seestar.core.streaming_stack import stack_disk_streaming

try:
    from seestar.gui.settings import SettingsManager, TILE_HEIGHT
except Exception:  # pragma: no cover - fallback for tests without GUI module
    try:
        from seestar.gui.settings import SettingsManager
    except Exception:
        SettingsManager = object
    TILE_HEIGHT = 512

# --- Third-Party Library Imports ---
from ..core.background import _PHOTOUTILS_AVAILABLE as _PHOTOUTILS_BG_SUB_AVAILABLE
from ..core.background import (
    subtract_background_2d,
)
from ..core.drizzle_utils import drizzle_finalize
from ..core.incremental_reprojection import (
    reproject_and_coadd_batch,
    reproject_and_combine,
    initialize_master,
)
from ..core.normalization import (
    _normalize_images_linear_fit,
    _normalize_images_sky_mean,
)
from ..core.reprojection import reproject_to_reference_wcs
from ..core.weights import (
    _calculate_image_weights_noise_fwhm,
    _calculate_image_weights_noise_variance,
)
from ..enhancement.stack_enhancement import apply_edge_crop

logger.debug("Imports tiers (numpy, cv2, astropy, ccdproc) OK.")

from time import monotonic
from time import monotonic as _mono

_DRZ_PREV_MIN_DT = 2.0  # secondes
_last_drz_prev = 0.0
_MAX_PREVIEW_SIDE_PX = 1000
_QM_LAST_GUI_PUSH = 0.0  # horodatage du dernier push
_QM_DEBOUNCE = 0.20  # secondes mini entre deux messages GUI
_BATCH_BREAK_TOKEN = "<BATCH_BREAK>"

# ----------------------------------------------------------------------
# Type aliases
# ----------------------------------------------------------------------

tBatchFiles = List[Tuple[str, List[str]]]

# ----------------------------------------------------------------------
# Pool size helper for CPU reprojection
# ----------------------------------------------------------------------


def _suggest_pool_size(fraction: float = 0.75) -> int:
    """Suggest a number of workers for a process pool.

    Parameters
    ----------
    fraction : float, optional
        Fraction of the available CPU cores to use. Defaults to ``0.75``.

    Returns
    -------
    int
        Recommended pool size, never less than ``1``.
    """
    import math

    n_cpu = max(os.cpu_count() or 1, 1)
    return max(1, math.ceil(n_cpu * fraction))


def _reproject_worker(
    fits_path: str,
    ref_wcs_header: fits.Header,
    shape_out: tuple,
    use_gpu: bool = False,
    match_background: bool = False,
):
    """Reproject a FITS image onto ``ref_wcs_header``.

    For ``batch_size == 1`` the GPU path is currently a placeholder and would
    produce an identity reprojection. To guarantee a correct result we force the
    CPU path even when ``use_gpu`` is ``True``.

    Parameters
    ----------
    fits_path : str
        Path to the FITS image to reproject.
    ref_wcs_header : fits.Header
        Header defining the target WCS grid.
    shape_out : tuple
        Output shape ``(H, W)`` for the reprojection.
    use_gpu : bool, optional
        Ignored. Present for API compatibility.
    match_background : bool, optional
        When ``True``, subtract a sigma-clipped median background from the
        reprojected image before returning it. Defaults to ``False``.
    """

    from seestar.enhancement.reproject_utils import reproject_interp

    logger.info(
        "[BATCH SIZE=1] _reproject_worker: using CPU WCS path (GPU disabled placeholder)."
    )

    with fits.open(fits_path, memmap=False) as hdul:
        data = hdul[0].data
        hdr  = hdul[0].header

        # --- [BS=1 FIX] Toujours tenter d'injecter/forcer le WCS corrigé (ASTAP/alignment) ---
        # On évite absolument d'utiliser le WCS brut d'origine.
        from seestar.utils.wcs_utils import inject_sanitized_wcs
        from astropy.io import fits as _fits
        import os, re

        input_wcs = None
        try:
            # 1) Injection (prend en compte sidecar ASTAP + sanitize CONTINUE)
            hdr_fixed = inject_sanitized_wcs(hdr, fits_path)
            if hdr_fixed is not None:
                hdr = hdr_fixed
                input_wcs = WCS(hdr, naxis=2)
                ensure_wcs_pixel_shape(
                    input_wcs,
                    int(hdr.get("NAXIS2")),
                    int(hdr.get("NAXIS1")),
                )
        except Exception as e:
            logger.warning("[B1] inject_sanitized_wcs failed for %s: %s", os.path.basename(fits_path), e)

        # 2) Fallback explicite: charger un sidecar .wcs si présent (et si l'injection n'a pas abouti)
        if input_wcs is None:
            base, _ = os.path.splitext(fits_path)
            sidecar = base + ".wcs"
            if os.path.isfile(sidecar):
                try:
                    txt = open(sidecar, "r", encoding="utf-8", errors="replace").read()
                    # Sanitize minimal: chaque CONTINUE doit porter une string
                    lines = []
                    for l in txt.splitlines():
                        l = l.strip()
                        if not l:
                            continue
                        if l.upper().startswith("CONTINUE"):
                            # Forcer guillemets si absents, pour astropy
                            if "'" not in l and '"' not in l:
                                payload = l.split(None, 1)[1] if " " in l else ""
                                l = f'CONTINUE "{payload}"'
                        lines.append(l)
                    txt = "\n".join(lines) + "\n"
                    h = _fits.Header.fromstring(txt, sep="\n")
                    input_wcs = WCS(h, naxis=2)
                    # On fusionne ce WCS au header courant pour garder les autres cartes utiles
                    for k, v in h.items():
                        hdr[k] = v
                except Exception as e:
                    logger.error("[B1] Failed parsing sidecar WCS for %s: %s", os.path.basename(fits_path), e)

        if input_wcs is None or not input_wcs.is_celestial:
            logger.error("[B1] No valid corrected WCS available for %s; skipping.", os.path.basename(fits_path))
            raise ValueError("Corrected WCS required but not found (BS=1).")

        # Harmoniser les dimensions WCS/data pour éviter des rotations implicites
        try:
            if data.ndim == 2:
                H, W = data.shape
            elif data.ndim == 3:
                # HWC ou CHW
                if data.shape[0] in (1,3,4) and data.shape[1] > 4 and data.shape[2] > 4:
                    # CHW (C,H,W)
                    H, W = int(data.shape[1]), int(data.shape[2])
                else:
                    # HWC
                    H, W = int(data.shape[0]), int(data.shape[1])
            else:
                raise ValueError(f"Unsupported ndim={data.ndim}")
            # Fixer la pixel_shape quand c'est possible
            try:
                input_wcs.pixel_shape = (int(W), int(H))
            except Exception:
                pass
        except Exception as e:
            logger.warning("[B1] Could not align WCS pixel_shape with data for %s: %s", os.path.basename(fits_path), e)

    target_wcs = WCS(ref_wcs_header, naxis=2)

    if data.ndim == 2:
        reproj, footprint = reproject_interp(
            (data, input_wcs), target_wcs, shape_out, parallel=False
        )
    elif data.ndim == 3:
        chw_like = (
            data.shape[0] in (1, 3, 4) and data.shape[-1] not in (1, 3, 4)
        )
