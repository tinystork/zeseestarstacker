                pass

            self.update_progress(
                f"üó∫Ô∏è Global grid : optimal {(out_shape_hw)} px",
                "INFO",
            )
            logger.debug(
                "DEBUG (Backend Grid Calc): optimal grid %dx%d scale=%.5f deg/pix",
                expected_wh[0],
                expected_wh[1],
                target_res_deg_per_pix,
            )

        return out_wcs, out_shape_hw

    ###########################################################################################################################################################

    def _prepare_global_reprojection_grid(self):
        """Solve all FITS files and compute the final mosaic grid."""
        self.update_progress(
            "üîç Pr√©-scan et r√©solution astrom√©trique de tous les fichiers...", 5
        )
        if not self.all_input_filepaths:
            try:
                self.all_input_filepaths = list(self.queue.queue)
            except Exception:
                self.all_input_filepaths = []

        wcs_list: list[WCS] = []
        header_list: list[fits.Header] = []

        solver_settings = {
            "local_solver_preference": self.local_solver_preference,
            "api_key": self.api_key,
            "astap_path": self.astap_path,
            "astap_data_dir": self.astap_data_dir,
            "astap_search_radius": self.astap_search_radius,
            "astap_downsample": self.astap_downsample,
            "astap_sensitivity": self.astap_sensitivity,
            "local_ansvr_path": self.local_ansvr_path,
            "scale_est_arcsec_per_pix": getattr(
                self, "reference_pixel_scale_arcsec", None
            ),
            "use_radec_hints": False,
        }

        total = len(self.all_input_filepaths)

        def _solve_single(path):
            try:
                hdr_local = fits.getheader(path, memmap=False)
                if self.astrometry_solver:
                    wcs_obj_local = self.astrometry_solver.solve(
                        path,
                        hdr_local,
                        solver_settings,
                        update_header_with_solution=False,
                        batch_size=getattr(self, "batch_size", None),
                        final_combine=getattr(self, "stack_final_combine", None),
                    )
                else:
                    wcs_obj_local = solve_image_wcs(
                        path,
                        hdr_local,
                        solver_settings,
                        update_header_with_solution=False,
                        batch_size=getattr(self, "batch_size", None),
                        final_combine=getattr(self, "stack_final_combine", None),
                    )
                return path, hdr_local, wcs_obj_local, None
            except Exception as exc:
                return path, None, None, exc

        max_workers = max(1, (os.cpu_count() or 1) // 2)
        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as ex:
            futures = [ex.submit(_solve_single, fp) for fp in self.all_input_filepaths]
            for idx, fut in enumerate(concurrent.futures.as_completed(futures), 1):
                if self.stop_processing:
                    for f in futures:
                        f.cancel()
                    return False

                fpath, hdr, wcs_obj, err = fut.result()
                self.update_progress(
                    f"   Solving {idx}/{total}: {os.path.basename(fpath)}",
                    5 + int(35 * ((idx - 1) / max(total, 1))),
                )

                if err is not None:
                    self.update_progress(
                        f"‚ö†Ô∏è [Pr√©-scan] Erreur WCS sur {os.path.basename(fpath)}: {err}",
                        "WARN",
                    )

                elif wcs_obj and wcs_obj.is_celestial:
                    wcs_list.append(wcs_obj)
                    header_list.append(hdr)
                else:
                    self.update_progress(
                        f"‚ö†Ô∏è [Pr√©-scan] √âchec r√©solution pour {os.path.basename(fpath)}",
