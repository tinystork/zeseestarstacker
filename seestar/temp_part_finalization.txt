            elif self.drizzle_active_session:
                logger.debug(
                    "DEBUG QM [_worker V_DrizIncrTrue_Fix1]: *** ENTR√âE DANS 'elif self.drizzle_active_session:' (NON-MOSA√èQUE) ***"
                )
                logger.debug(
                    f"DEBUG QM [_worker/Finalize DrizzleStd]: Mode Drizzle Standard: {self.drizzle_mode}"
                )

                if current_batch_items_with_masks_for_stack_batch:
                    self.stacked_batches_count += 1
                    self._send_eta_update()
                    num_in_partial_batch = len(
                        current_batch_items_with_masks_for_stack_batch
                    )
                    progress_info_partial_log = f"(Lot PARTIEL {self.stacked_batches_count}/{self.total_batches_estimated if self.total_batches_estimated > 0 else '?'})"

                    if self.drizzle_mode == "Final":
                        self.update_progress(
                            f"üíß Traitement Drizzle (mode Final) du dernier lot partiel {progress_info_partial_log}..."
                        )
                        # Utilisation d'un ProcessPoolExecutor pour ne pas bloquer
                        # le thread principal lorsque le lot est volumineux.
                        with ProcessPoolExecutor(
                            max_workers=1, mp_context=get_context("spawn")
                        ) as driz_exec:
                            (
                                batch_sci_path,
                                batch_wht_paths,
                            ) = driz_exec.submit(
                                self._process_and_save_drizzle_batch,
                                current_batch_items_with_masks_for_stack_batch,  # Liste de CHEMINS
                                self.drizzle_output_wcs,
                                self.drizzle_output_shape_hw,
                                self.stacked_batches_count,
                            ).result()
                        if batch_sci_path and batch_wht_paths:
                            self.intermediate_drizzle_batch_files.append(
                                (batch_sci_path, batch_wht_paths)
                            )
                        else:
                            self.failed_stack_count += len(
                                current_batch_items_with_masks_for_stack_batch
                            )

                    elif self.drizzle_mode == "Incremental":  # VRAI Drizzle Incr√©mental
                        self.update_progress(
                            f"üíß Traitement Drizzle Incr. VRAI du dernier lot partiel {progress_info_partial_log}..."
                        )
                        fut = self.drizzle_executor.submit(
                            self._process_incremental_drizzle_batch,  # Utilise la version V_True_Incremental_Driz
                            current_batch_items_with_masks_for_stack_batch,  # Liste de CHEMINS
                            self.stacked_batches_count,
                            self.total_batches_estimated,
                        )
                        result = fut.result()
                        if result and isinstance(result, tuple) and len(result) == 2:
                            sci_arrs, wht_arrs = result
                            for idx, driz in enumerate(
                                self.incremental_drizzle_objects or []
                            ):
                                if idx < len(sci_arrs) and idx < len(wht_arrs):
                                    driz.out_img[...] = sci_arrs[idx]
                                    driz.out_wht[...] = wht_arrs[idx]
                            self.incremental_drizzle_sci_arrays = sci_arrs
                            self.incremental_drizzle_wht_arrays = wht_arrs

                    self._move_to_stacked(self._current_batch_paths)
                    self._save_partial_stack()
                    self._update_batch_count_file()
                    self._current_batch_paths = []

                    current_batch_items_with_masks_for_stack_batch = []

                # Prefer Reproject&Coadd when batch_size==0 (align behaviour with WIP)
                if getattr(self, "batch_size", 0) == 0 and self.reproject_coadd_final:
                    self.update_progress("ÔøΩY?? Finalisation Reproject&Coadd...")

                    solved_batches = [
                        bf
                        for bf in self.intermediate_classic_batch_files
                        if bf[0]
                        not in getattr(self, "unsolved_classic_batch_files", set())
                    ]
                    if solved_batches:
                        if len(solved_batches) == 1:
                            self._finalize_single_classic_batch(solved_batches[0])
                        elif not self._reproject_classic_batches_zm(solved_batches):
                            if self._reproject_classic_batches(solved_batches):
                                self._save_final_stack(
                                    "_classic_reproject",
                                    drizzle_final_sci_data=self.current_stack,
                                    drizzle_final_wht_data=self.current_coverage,
                                    preserve_linear_output=True,
                                )
                            else:
                                self.update_progress(
                                    "   Reprojection finale «∏chou«∏e.", "WARN"
                                )
                                self.final_stacked_path = None

                    else:
                        self.update_progress(
                            "   Aucune image accumul«∏e pour sauvegarde."
                        )
                        self.final_stacked_path = None
                elif self.reproject_between_batches:
                    self.update_progress("ÔøΩY?? Finalisation Stacking (Reprojection)...")
                    if self.images_in_cumulative_stack > 0 or (
                        hasattr(self, "cumulative_sum_memmap")
                        and self.cumulative_sum_memmap is not None
                    ):
                        self._save_final_stack(
                            output_filename_suffix="_classic_reproject"
                        )
                    else:
                        self.update_progress(
                            "   Aucune image accumul√©e pour sauvegarde."
                        )
                        self.final_stacked_path = None
                # --- Sauvegarde finale sp√©cifique au mode Drizzle ---
                if self.drizzle_mode == "Incremental":
                    self.update_progress(
                        "üèÅ Finalisation Drizzle Incr√©mental VRAI (depuis objets Drizzle)..."
                    )
                    # Pour le VRAI Drizzle Incr√©mental, _save_final_stack doit lire depuis
                    # self.incremental_drizzle_objects/arrays. Ne pas passer drizzle_final_sci_data.
                    self._save_final_stack(
                        output_filename_suffix="_drizzle_incr_true"
                    )  # MODIFI√â ICI

                elif self.drizzle_mode == "Final":
                    self.update_progress(
                        "üèÅ Combinaison finale des lots Drizzle (Mode Final)..."
                    )
                    if not self.intermediate_drizzle_batch_files:
                        self.update_progress(
                            "   ‚ùå Drizzle Final: Aucun lot interm√©diaire √† combiner.",
                            None,
                        )
                        self.processing_error = "Drizzle Final: Aucun lot interm√©diaire"
                        self.final_stacked_path = None
                    else:
                        fut = self.drizzle_executor.submit(
                            drizzle_final_worker,
                            (
                                self,
                                self.intermediate_drizzle_batch_files,
                                self.drizzle_output_wcs,
                                self.drizzle_output_shape_hw,
                            ),
                        )
                        (
                            final_drizzle_sci_hxwxc,
                            final_drizzle_wht_hxwxc,
                        ) = fut.result()
                        if final_drizzle_sci_hxwxc is not None:
                            self.update_progress(
                                "   Drizzle Final combin√©. Pr√©paration sauvegarde..."
                            )
                            self._save_final_stack(
                                output_filename_suffix="_drizzle_final",  # Suffixe correct
                                drizzle_final_sci_data=final_drizzle_sci_hxwxc,
                                drizzle_final_wht_data=final_drizzle_wht_hxwxc,
                            )
                        else:
                            self.update_progress(
                                "   ‚ùå √âchec combinaison finale des lots Drizzle (r√©sultat vide).",
                                None,
                            )
                            self.processing_error = "√âchec combinaison Drizzle Final"
                            self.final_stacked_path = None

            # --- MODE STACKING CLASSIQUE (NON-MOSA√èQUE, NON-DRIZZLE) ---
            elif not self.is_mosaic_run and not self.drizzle_active_session:
                logger.debug(
                    "DEBUG QM [_worker Finalize]: Finalisation Stacking Classique (ou Reprojection)."
                )

                if (
                    self.reproject_between_batches
                    and current_batch_items_with_masks_for_stack_batch
                ):
                    self.stacked_batches_count += 1
                    self._send_eta_update()
                    num_in_batch = len(current_batch_items_with_masks_for_stack_batch)
                    self.update_progress(
                        f"‚öôÔ∏è Traitement classique du dernier lot partiel ({num_in_batch} images)..."
                    )

                    stacked_np, hdr, wht_2d = self._stack_batch(
                        current_batch_items_with_masks_for_stack_batch,
                        self.stacked_batches_count,
                        self.total_batches_estimated,
                    )
                    if stacked_np is not None:
                        solved_path, _ = self._save_and_solve_classic_batch(
                            stacked_np, wht_2d, hdr, self.stacked_batches_count
                        )
                        batch_wcs = None
                        try:
                            batch_wcs = WCS(hdr, naxis=2)
                            ensure_wcs_pixel_shape(
                                batch_wcs,
                                int(hdr.get("NAXIS2")),
                                int(hdr.get("NAXIS1")),
                            )
                        except Exception:
                            batch_wcs = None

                        if (
                            not (
                                self.reproject_between_batches
                                or self.reproject_coadd_final
                            )
                            or self._last_classic_batch_solved
                        ):
                            self._combine_batch_result(
                                stacked_np,
                                hdr,
                                wht_2d,
                                batch_wcs=batch_wcs,
                            )
                        else:
                            self.update_progress(
                                "   -> Batch sans r\xe9solution ignor\xe9 pour le reproject",
                                "WARN",
                            )

                        if self.reproject_between_batches:
                            stack_img, solved_hdr = self._solve_cumulative_stack()
                            if stack_img is not None and solved_hdr is not None:
                                reference_image_data_for_global_alignment = stack_img
                                reference_header_for_global_alignment = (
                                    solved_hdr.copy()
                                )
                            else:
                                reference_image_data_for_global_alignment = (
                                    stacked_np.astype(np.float32, copy=True)
                                )
                                reference_header_for_global_alignment = hdr.copy()
                        else:
                            reference_image_data_for_global_alignment = (
                                stacked_np.astype(np.float32, copy=True)
                            )
                            reference_header_for_global_alignment = hdr.copy()

                        if hasattr(self.cumulative_sum_memmap, "flush"):
                            self.cumulative_sum_memmap.flush()
                        if hasattr(self.cumulative_wht_memmap, "flush"):
                            self.cumulative_wht_memmap.flush()
                        self._update_preview_sum_w()
                        self._move_to_stacked(self._current_batch_paths)
                        self._save_partial_stack()
                        self._update_batch_count_file()
                        self._current_batch_paths = []
                    else:
                        self.update_progress(
                            "   -> √âchec combinaison du dernier lot partiel", "ERROR"
                        )

                    if self.move_stacked and self._current_batch_paths:
                        move_to_stacked(
                            self._current_batch_paths,
                            self.update_progress,
                            self.stacked_subdir_name,
                        )
                        self._current_batch_paths = []
                    self._update_batches_meta()
                    self._save_partial_stack()
                    current_batch_items_with_masks_for_stack_batch = []
                    gc.collect()

                elif (
                    not self.reproject_between_batches
                    and current_batch_items_with_masks_for_stack_batch
                ):
                    self.stacked_batches_count += 1
                    self._send_eta_update()
                    self.update_progress(
                        f"‚öôÔ∏è Traitement classique du dernier lot partiel ({len(current_batch_items_with_masks_for_stack_batch)} images)..."
                    )
                    self._process_completed_batch(
                        current_batch_items_with_masks_for_stack_batch,
                        self.stacked_batches_count,
                        self.total_batches_estimated,
                        self.reference_wcs_object,
                    )
                    self._move_to_stacked(self._current_batch_paths)
                    self._save_partial_stack()
                    self._update_batch_count_file()
                    self._current_batch_paths = []

                    current_batch_items_with_masks_for_stack_batch = []

                if self.reproject_between_batches:
                    self.update_progress("üèÅ Finalisation Stacking (Reprojection)...")
                    if self.images_in_cumulative_stack > 0 or (
                        hasattr(self, "cumulative_sum_memmap")
                        and self.cumulative_sum_memmap is not None
                    ):
                        self._save_final_stack(
                            output_filename_suffix="_classic_reproject"
                        )
                    else:
                        self.update_progress(
                            "   Aucune image accumul√©e pour sauvegarde."
                        )
                        self.final_stacked_path = None
                elif self.reproject_coadd_final:
                    self.update_progress("üèÅ Finalisation Reproject&Coadd...")

                    solved_batches = [
                        bf
                        for bf in self.intermediate_classic_batch_files
                        if bf[0]
                        not in getattr(self, "unsolved_classic_batch_files", set())
                    ]
                    if solved_batches:
                        if len(solved_batches) == 1:
                            self._finalize_single_classic_batch(solved_batches[0])
                        elif not self._reproject_classic_batches_zm(solved_batches):
                            if self._reproject_classic_batches(solved_batches):
                                self._save_final_stack(
                                    "_classic_reproject",
                                    drizzle_final_sci_data=self.current_stack,
                                    drizzle_final_wht_data=self.current_coverage,
                                    preserve_linear_output=True,
                                )
                            else:
                                self.update_progress(
                                    "   Reprojection finale √©chou√©e.", "WARN"
                                )
                                self.final_stacked_path = None

                    else:
                        self.update_progress(
                            "   Aucune batch sauvegard√© pour reproject&coadd.",
                        )
                        self.final_stacked_path = None
                else:
                    self.update_progress(
                        "üèÅ Finalisation Stacking Classique (SUM/W)..."
                    )
                    if self.images_in_cumulative_stack > 0 or (
                        hasattr(self, "cumulative_sum_memmap")
                        and self.cumulative_sum_memmap is not None
                    ):
                        self._save_final_stack(output_filename_suffix="_classic_sumw")
                    else:
                        self.update_progress(
                            "   Aucune image accumul√©e dans le stack classique. Sauvegarde ignor√©e."
                        )
                        self.final_stacked_path = None
            else:  # Cas impr√©vu
                logger.debug(
                    "DEBUG QM [_worker V_DrizIncrTrue_Fix1]: *** ENTR√âE DANS LE 'else' FINAL (√âTAT NON G√âR√â) ***"
                )
                self.update_progress(
                    "‚ö†Ô∏è √âtat de finalisation non g√©r√©. Aucune action de sauvegarde principale."
                )
                self.processing_error = "√âtat de finalisation non g√©r√©."
                self.final_stacked_path = None

            logger.debug(
                "DEBUG QM [_worker V_DrizIncrTrue_Fix1]: *** APR√àS LE BLOC if/elif/else DE FINALISATION ***"
            )
            if (not ibn_finalized) and getattr(self, "interbatch_norm_active", False):
                self._interbatch_finalize_session()
                ibn_finalized = True

        # --- FIN DU BLOC TRY PRINCIPAL DU WORKER ---
        except RuntimeError as rte:
            self.update_progress(
                f"‚ùå ERREUR CRITIQUE (RuntimeError) dans le worker: {rte}", "ERROR"
            )  # S'assurer que "ERROR" est pass√© pour le log GUI
            logger.debug(f"ERREUR QM [_worker V_NoDerotation]: RuntimeError: {rte}")
            traceback.print_exc(limit=3)
            self.processing_error = f"RuntimeError: {rte}"
            self.stop_processing = True  # Provoquer l'arr√™t propre du thread
        except Exception as e_global_worker:
            self.update_progress(
                f"‚ùå ERREUR INATTENDUE GLOBALE dans le worker: {e_global_worker}",
                "ERROR",
            )
            logger.debug(
                f"ERREUR QM [_worker V_NoDerotation]: Exception Globale: {e_global_worker}"
            )
            traceback.print_exc(limit=3)
            self.processing_error = f"Erreur Globale: {e_global_worker}"
            self.stop_processing = True  # Provoquer l'arr√™t propre du thread
        finally:
            logger.debug(
                f"DEBUG QM [_worker V_NoDerotation]: Entree dans le bloc FINALLY principal du worker."
            )
            if (not ibn_finalized) and getattr(self, "interbatch_norm_active", False):
                self._interbatch_finalize_session()
            if (
                hasattr(self, "cumulative_sum_memmap")
                and self.cumulative_sum_memmap is not None
                or hasattr(self, "cumulative_wht_memmap")
                and self.cumulative_wht_memmap is not None
            ):
                self._close_memmaps()

            if self.perform_cleanup:
                self.update_progress("üßπ Nettoyage final des fichiers temporaires...")
                self._cleanup_drizzle_temp_files()  # Dossier des inputs Drizzle (aligned_input_*.fits)
                self._cleanup_aligned_temp_files()  # Fichiers align√©s batch=1
                self._cleanup_drizzle_batch_outputs()  # Dossier des sorties Drizzle par lot (batch_*_sci.fits, batch_*_wht_*.fits)
                self._cleanup_classic_batch_outputs()  # Dossier des sorties Classic par lot
                self._cleanup_mosaic_panel_stacks_temp()  # Dossier des stacks de panneaux (si ancienne logique ou tests)
                if not self.user_requested_stop:
                    self.cleanup_temp_reference()  # Fichiers reference_image.fit/png
                if not self.stop_processing:
                    self._cleanup_memmap_files()

            self.processing_active = False
            self.stop_processing_flag_for_gui = (
                self.stop_processing
            )  # Transmettre l'√©tat d'arr√™t √† l'UI
            if self.autotuner:
                self.autotuner.stop()
            self.__class__.stop_processing(self)
            gc.collect()
            logger.debug(
                f"DEBUG QM [_worker V_NoDerotation]: Fin du bloc FINALLY principal. Flag processing_active mis √† False."
            )
            self.update_progress("üö™ Thread de traitement principal termin√©.")

    ############################################################################################################################

    # --- DANS LA CLASSE SeestarQueuedStacker DANS seestar/queuep/queue_manager.py ---

    def _generate_and_save_mosaic_alignment_log(
        self,
        all_aligned_panel_info_list: list,
        anchor_wcs_details: dict,
        final_output_grid_details: dict,
    ):
        """
        G√©n√®re un log d√©taill√© sur l'alignement de la mosa√Øque et le sauvegarde.
        MODIFIED V2: Gestion plus robuste de la lecture de _ALIGN_METHOD_LOG depuis le header.
        """
        if not self.output_folder:
            logger.debug(
                "WARN QM [_generate_mosaic_log V2]: Output folder non d√©fini, log non sauvegard√©."
            )
            return

        log_lines = []
        separator = "=" * 70

        log_lines.append(
            f"{separator}\nRAPPORT D'ALIGNEMENT DE MOSA√èQUE (V2)\n{separator}"
        )
        log_lines.append(f"Date du rapport: {time.strftime('%Y-%m-%d %H:%M:%S')}")
        log_lines.append(f"Dossier de sortie: {self.output_folder}")

        # --- 1. Param√®tres Cl√©s de la Mosa√Øque ---
        log_lines.append(f"\n--- Param√®tres de la Mosa√Øque Utilis√©s ---")
        log_lines.append(
            f"  Mode d'alignement: {getattr(self, 'mosaic_alignment_mode', 'N/A')}"
        )
        log_lines.append(
            f"  Fallback WCS activ√©: {getattr(self, 'use_wcs_fallback_for_mosaic', 'N/A')}"
        )
        log_lines.append(
            f"  FastAligner - Seuil RANSAC: {getattr(self, 'fa_ransac_thresh', 'N/A')}"
        )
        log_lines.append(
            f"  FastAligner - Min Abs Matches: {getattr(self, 'fa_min_abs_matches', 'N/A')}"
        )
        log_lines.append(
            f"  FastAligner - Min RANSAC Raw (valeur config): {getattr(self, 'fa_min_ransac_raw', 'N/A')}"
        )
        log_lines.append(
            f"  FastAligner - ORB Features (cible): {getattr(self, 'fa_orb_features', 'N/A')}"
        )
        log_lines.append(
            f"  FastAligner DAO - FWHM: {getattr(self, 'fa_daofind_fwhm', 'N/A')}"
        )
        log_lines.append(
            f"  FastAligner DAO - Seuil Sigma Factor: {getattr(self, 'fa_daofind_thr_sig', 'N/A')}"
        )
        log_lines.append(
            f"  FastAligner DAO - Max √âtoiles Desc.: {getattr(self, 'fa_max_stars_descr', 'N/A')}"
        )
        log_lines.append(
            f"  Drizzle Mosa√Øque - Kernel: {getattr(self, 'mosaic_drizzle_kernel', 'N/A')}"
        )
        log_lines.append(
            f"  Drizzle Mosa√Øque - Pixfrac: {getattr(self, 'mosaic_drizzle_pixfrac', 'N/A')}"
        )
        log_lines.append(
            f"  Drizzle Mosa√Øque - WHT Threshold: {getattr(self, 'mosaic_drizzle_wht_threshold', 'N/A')}"
        )
        log_lines.append(
            f"  Drizzle Mosa√Øque - √âchelle Globale Appliqu√©e: {getattr(self, 'drizzle_scale', 'N/A')}x"
        )

