                    )
                    self.processing_error = "MosaÃ¯que: Aucun panneau alignÃ©"
                    self.final_stacked_path = None
                else:
                    try:
                        self._finalize_mosaic_processing(
                            all_aligned_files_with_info_for_mosaic
                        )
                    except Exception as e_finalize_mosaic:
                        # ... (gestion erreur identique)
                        error_msg = f"Erreur CRITIQUE durant finalisation mosaÃ¯que: {e_finalize_mosaic}"
                        logger.debug(
                            f"ERREUR QM [_worker V_DrizIncrTrue_Fix1]: {error_msg}"
                        )
                        traceback.print_exc(limit=3)
                        self.update_progress(f"   âŒ {error_msg}", "ERROR")
                        self.processing_error = error_msg
                        self.final_stacked_path = None

            # --- MODE DRIZZLE STANDARD (NON-MOSAÃQUE) ---
            elif self.drizzle_active_session:
                logger.debug(
                    "DEBUG QM [_worker V_DrizIncrTrue_Fix1]: *** ENTRÃ‰E DANS 'elif self.drizzle_active_session:' (NON-MOSAÃQUE) ***"
                )
                logger.debug(
                    f"DEBUG QM [_worker/Finalize DrizzleStd]: Mode Drizzle Standard: {self.drizzle_mode}"
                )

                if current_batch_items_with_masks_for_stack_batch:
                    self.stacked_batches_count += 1
                    self._send_eta_update()
                    num_in_partial_batch = len(
                        current_batch_items_with_masks_for_stack_batch
                    )
                    progress_info_partial_log = f"(Lot PARTIEL {self.stacked_batches_count}/{self.total_batches_estimated if self.total_batches_estimated > 0 else '?'})"

                    if self.drizzle_mode == "Final":
                        self.update_progress(
                            f"ðŸ’§ Traitement Drizzle (mode Final) du dernier lot partiel {progress_info_partial_log}..."
                        )
                        # Utilisation d'un ProcessPoolExecutor pour ne pas bloquer
                        # le thread principal lorsque le lot est volumineux.
                        with ProcessPoolExecutor(
                            max_workers=1, mp_context=get_context("spawn")
                        ) as driz_exec:
                            (
                                batch_sci_path,
                                batch_wht_paths,
                            ) = driz_exec.submit(
                                self._process_and_save_drizzle_batch,
                                current_batch_items_with_masks_for_stack_batch,  # Liste de CHEMINS
                                self.drizzle_output_wcs,
                                self.drizzle_output_shape_hw,
                                self.stacked_batches_count,
                            ).result()
                        if batch_sci_path and batch_wht_paths:
                            self.intermediate_drizzle_batch_files.append(
                                (batch_sci_path, batch_wht_paths)
                            )
                        else:
                            self.failed_stack_count += len(
                                current_batch_items_with_masks_for_stack_batch
                            )

                    elif self.drizzle_mode == "Incremental":  # VRAI Drizzle IncrÃ©mental
                        self.update_progress(
                            f"ðŸ’§ Traitement Drizzle Incr. VRAI du dernier lot partiel {progress_info_partial_log}..."
                        )
                        fut = self.drizzle_executor.submit(
                            self._process_incremental_drizzle_batch,  # Utilise la version V_True_Incremental_Driz
                            current_batch_items_with_masks_for_stack_batch,  # Liste de CHEMINS
                            self.stacked_batches_count,
                            self.total_batches_estimated,
                        )
                        result = fut.result()
                        if result and isinstance(result, tuple) and len(result) == 2:
                            sci_arrs, wht_arrs = result
                            for idx, driz in enumerate(
                                self.incremental_drizzle_objects or []
                            ):
                                if idx < len(sci_arrs) and idx < len(wht_arrs):
                                    driz.out_img[...] = sci_arrs[idx]
                                    driz.out_wht[...] = wht_arrs[idx]
                            self.incremental_drizzle_sci_arrays = sci_arrs
                            self.incremental_drizzle_wht_arrays = wht_arrs

                    self._move_to_stacked(self._current_batch_paths)
                    self._save_partial_stack()
                    self._update_batch_count_file()
                    self._current_batch_paths = []

                    current_batch_items_with_masks_for_stack_batch = []

                # Prefer Reproject&Coadd when batch_size==0 (align behaviour with WIP)
                if getattr(self, "batch_size", 0) == 0 and self.reproject_coadd_final:
                    self.update_progress("ï¿½Y?? Finalisation Reproject&Coadd...")

                    solved_batches = [
                        bf
                        for bf in self.intermediate_classic_batch_files
                        if bf[0]
                        not in getattr(self, "unsolved_classic_batch_files", set())
                    ]
                    if solved_batches:
                        if len(solved_batches) == 1:
                            self._finalize_single_classic_batch(solved_batches[0])
                        elif not self._reproject_classic_batches_zm(solved_batches):
                            if self._reproject_classic_batches(solved_batches):
                                self._save_final_stack(
                                    "_classic_reproject",
                                    drizzle_final_sci_data=self.current_stack,
                                    drizzle_final_wht_data=self.current_coverage,
                                    preserve_linear_output=True,
                                )
                            else:
                                self.update_progress(
                                    "   Reprojection finale Ç¸chouÇ¸e.", "WARN"
                                )
                                self.final_stacked_path = None

                    else:
                        self.update_progress(
                            "   Aucune image accumulÇ¸e pour sauvegarde."
                        )
                        self.final_stacked_path = None
                elif self.reproject_between_batches:
                    self.update_progress("ï¿½Y?? Finalisation Stacking (Reprojection)...")
                    if self.images_in_cumulative_stack > 0 or (
                        hasattr(self, "cumulative_sum_memmap")
                        and self.cumulative_sum_memmap is not None
                    ):
                        self._save_final_stack(
                            output_filename_suffix="_classic_reproject"
                        )
                    else:
                        self.update_progress(
                            "   Aucune image accumulÃ©e pour sauvegarde."
                        )
                        self.final_stacked_path = None
                # --- Sauvegarde finale spÃ©cifique au mode Drizzle ---
                if self.drizzle_mode == "Incremental":
                    self.update_progress(
                        "ðŸ Finalisation Drizzle IncrÃ©mental VRAI (depuis objets Drizzle)..."
                    )
                    # Pour le VRAI Drizzle IncrÃ©mental, _save_final_stack doit lire depuis
                    # self.incremental_drizzle_objects/arrays. Ne pas passer drizzle_final_sci_data.
                    self._save_final_stack(
                        output_filename_suffix="_drizzle_incr_true"
                    )  # MODIFIÃ‰ ICI

                elif self.drizzle_mode == "Final":
                    self.update_progress(
                        "ðŸ Combinaison finale des lots Drizzle (Mode Final)..."
                    )
                    if not self.intermediate_drizzle_batch_files:
                        self.update_progress(
                            "   âŒ Drizzle Final: Aucun lot intermÃ©diaire Ã  combiner.",
                            None,
                        )
                        self.processing_error = "Drizzle Final: Aucun lot intermÃ©diaire"
                        self.final_stacked_path = None
                    else:
                        fut = self.drizzle_executor.submit(
                            drizzle_final_worker,
                            (
                                self,
                                self.intermediate_drizzle_batch_files,
                                self.drizzle_output_wcs,
                                self.drizzle_output_shape_hw,
                            ),
                        )
                        (
                            final_drizzle_sci_hxwxc,
                            final_drizzle_wht_hxwxc,
                        ) = fut.result()
                        if final_drizzle_sci_hxwxc is not None:
                            self.update_progress(
                                "   Drizzle Final combinÃ©. PrÃ©paration sauvegarde..."
                            )
                            self._save_final_stack(
                                output_filename_suffix="_drizzle_final",  # Suffixe correct
                                drizzle_final_sci_data=final_drizzle_sci_hxwxc,
                                drizzle_final_wht_data=final_drizzle_wht_hxwxc,
                            )
                        else:
                            self.update_progress(
                                "   âŒ Ã‰chec combinaison finale des lots Drizzle (rÃ©sultat vide).",
                                None,
                            )
                            self.processing_error = "Ã‰chec combinaison Drizzle Final"
                            self.final_stacked_path = None

            # --- MODE STACKING CLASSIQUE (NON-MOSAÃQUE, NON-DRIZZLE) ---
            elif not self.is_mosaic_run and not self.drizzle_active_session:
                logger.debug(
                    "DEBUG QM [_worker Finalize]: Finalisation Stacking Classique (ou Reprojection)."
                )

                if (
                    self.reproject_between_batches
                    and current_batch_items_with_masks_for_stack_batch
                ):
                    self.stacked_batches_count += 1
                    self._send_eta_update()
                    num_in_batch = len(current_batch_items_with_masks_for_stack_batch)
                    self.update_progress(
                        f"âš™ï¸ Traitement classique du dernier lot partiel ({num_in_batch} images)..."
                    )

                    stacked_np, hdr, wht_2d = self._stack_batch(
                        current_batch_items_with_masks_for_stack_batch,
                        self.stacked_batches_count,
                        self.total_batches_estimated,
                    )
                    if stacked_np is not None:
                        solved_path, _ = self._save_and_solve_classic_batch(
                            stacked_np, wht_2d, hdr, self.stacked_batches_count
                        )
                        batch_wcs = None
                        try:
                            batch_wcs = WCS(hdr, naxis=2)
                            ensure_wcs_pixel_shape(
                                batch_wcs,
                                int(hdr.get("NAXIS2")),
                                int(hdr.get("NAXIS1")),
                            )
                        except Exception:
                            batch_wcs = None

                        if (
                            not (
                                self.reproject_between_batches
                                or self.reproject_coadd_final
                            )
                            or self._last_classic_batch_solved
                        ):
                            self._combine_batch_result(
                                stacked_np,
                                hdr,
                                wht_2d,
                                batch_wcs=batch_wcs,
                            )
                        else:
                            self.update_progress(
                                "   -> Batch sans r\xe9solution ignor\xe9 pour le reproject",
                                "WARN",
                            )

                        if self.reproject_between_batches:
                            stack_img, solved_hdr = self._solve_cumulative_stack()
                            if stack_img is not None and solved_hdr is not None:
                                reference_image_data_for_global_alignment = stack_img
                                reference_header_for_global_alignment = (
                                    solved_hdr.copy()
                                )
                            else:
                                reference_image_data_for_global_alignment = (
                                    stacked_np.astype(np.float32, copy=True)
                                )
                                reference_header_for_global_alignment = hdr.copy()
                        else:
                            reference_image_data_for_global_alignment = (
                                stacked_np.astype(np.float32, copy=True)
                            )
                            reference_header_for_global_alignment = hdr.copy()

                        if hasattr(self.cumulative_sum_memmap, "flush"):
                            self.cumulative_sum_memmap.flush()
                        if hasattr(self.cumulative_wht_memmap, "flush"):
                            self.cumulative_wht_memmap.flush()
                        self._update_preview_sum_w()
                        self._move_to_stacked(self._current_batch_paths)
                        self._save_partial_stack()
                        self._update_batch_count_file()
                        self._current_batch_paths = []
                    else:
                        self.update_progress(
                            "   -> Ã‰chec combinaison du dernier lot partiel", "ERROR"
                        )

                    if self.move_stacked and self._current_batch_paths:
                        move_to_stacked(
                            self._current_batch_paths,
                            self.update_progress,
                            self.stacked_subdir_name,
                        )
                        self._current_batch_paths = []
                    self._update_batches_meta()
                    self._save_partial_stack()
                    current_batch_items_with_masks_for_stack_batch = []
                    gc.collect()

                elif (
                    not self.reproject_between_batches
                    and current_batch_items_with_masks_for_stack_batch
                ):
                    self.stacked_batches_count += 1
                    self._send_eta_update()
                    self.update_progress(
                        f"âš™ï¸ Traitement classique du dernier lot partiel ({len(current_batch_items_with_masks_for_stack_batch)} images)..."
                    )
                    self._process_completed_batch(
                        current_batch_items_with_masks_for_stack_batch,
                        self.stacked_batches_count,
                        self.total_batches_estimated,
                        self.reference_wcs_object,
                    )
                    self._move_to_stacked(self._current_batch_paths)
                    self._save_partial_stack()
                    self._update_batch_count_file()
                    self._current_batch_paths = []

                    current_batch_items_with_masks_for_stack_batch = []

                if self.reproject_between_batches:
                    self.update_progress("ðŸ Finalisation Stacking (Reprojection)...")
                    if self.images_in_cumulative_stack > 0 or (
                        hasattr(self, "cumulative_sum_memmap")
                        and self.cumulative_sum_memmap is not None
                    ):
